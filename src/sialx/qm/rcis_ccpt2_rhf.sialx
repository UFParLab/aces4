#  Copyright (c) 2003-2010 University of Florida
  import "rccsd_rhf_defs.sialx" 
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
                           SIAL CCSD_RHF_SV1
#
#-------------------------------------------------------------------------------
#
# Declare indeces 
# --------------- 
#
      index kiter    = 1, cc_iter   
      index   kbeg   = 1, scf_beg # Change to cc_beg 
      index   korder = 1, scf_hist # Change to cc_hist 
      index   kone   = 1, 1
      index   kdiis  = 1, 30 
      index   k1diis = 1, 30 
      index   jdiis  = 1, 30 
      index   j1diis = 1, 30 
      index      D1  = 1, 30 
      index      D2  = 1, 30 
      index kstate   = 1, eom_roots
      index kstate1  = 1, eom_roots
      index pstate   = eom_roots2, eom_subspc
      index ksub  = 1, eom_subspc
      index ksub1 = 1, eom_subspc
#
      aoindex mu     = 1, norb 
      aoindex nu     = 1, norb
      aoindex lambda = 1, norb
      aoindex sigma  = 1, norb
#
      moaindex i = baocc, eaocc
      moaindex i1= baocc, eaocc
      moaindex i2= baocc, eaocc
      moaindex i3= baocc, eaocc
#
      moaindex a = bavirt, eavirt
      moaindex a1= bavirt, eavirt
      moaindex a2= bavirt, eavirt
      moaindex a3= bavirt, eavirt
#
      moaindex j = baocc, eaocc
      moaindex j1= baocc, eaocc
      moaindex j2= baocc, eaocc
      moaindex j3= baocc, eaocc
#
      moaindex b = bavirt, eavirt
      moaindex b1= bavirt, eavirt
      moaindex b2= bavirt, eavirt
      moaindex b3= bavirt, eavirt
#
      moaindex p = baocc, eavirt
      moaindex p1= baocc, eavirt
      moaindex p2= baocc, eavirt
      moaindex p3= baocc, eavirt
#
      moaindex q = baocc, eavirt
      moaindex q1= baocc, eavirt
      moaindex q2= baocc, eavirt
      moaindex q3= baocc, eavirt
# 
# Declare static arrays 
# --------------------- 
#
      distributed t1a_old(a,i) 
      distributed t1a_new(a,i) 
#
      distributed Fae_a(a,a1) 
      distributed Fme_a(i,a) 
      distributed Fmi_a(i,i1) 
      distributed DCa(mu,p) 
      distributed FTa(p,p1) 

      static zz(mu,nu) 
      static ca(mu,p) 
      static fock_a(p,p1) 
#
# Arrays used in the DIIS 
# -----------------------
#
      served Daibj(a,i,b,j,kdiis) 
      served Eaibj(a,i,b,j,jdiis) 
      distributed Dai(a,i,kdiis) 
      distributed Eai(a,i,jdiis) 
      served D0aibj(a,i,b,j) 
      served D0ai(a,i) 

      temp Taibjk(a,i,b,j,kdiis) 
      static BB(d1,d2) 
      temp tbb(d1,d2) 
      distributed DIST_BB(d1,d2) 
      scalar n1 
      scalar n2 
      scalar worder  
#
# Arrays used in transformation for AO2 algorithm
# -----------------------------------------------
#
      served VSpipi(p1,i,p,i1)
      served Viaai(i,a1,a,i1) 
      served Vaaii(a,a1,i,i1)
      served Vaaai(a2,a,a1,i)
#
      temp Txixj(mu,i,nu,j)
      served Vpiqj(p,i,q,j)
#
# End Arrays used in transformation for AO2 algorithm
# --------------------------------------------------- 
#
# Declare temporary arrays 
# ------------------------ 
#
      temp Txjjx(mu,j,j1,nu)
      temp Txijx(mu,i,j,nu)
      temp Txqii(mu,q,i,i1)
      temp Tqqii(q,q1,i,i1)
      temp Txpjj(mu,p,j,j1)
      temp Txqjj(mu,q,j,j1)
      temp Tppjj(p,p1,j,j1)
      temp Tqqjj(q,q1,j,j1)
      temp Tjxqj(j,mu,q,j1)
      temp Tjqqj(j,q,q1,j1)
      temp Tixqj(i,mu,q,j)
      temp Tipqj(i,p,q,j)
#
      temp Taiai(p,i,p1,i1)
      temp T1aiai(p,i,p1,i1)
      temp T2aiai(p,i,p1,i1)
      temp T3aiai(p,i,p1,i1)
      temp Tbjbj(q,j,q1,j1)
      temp T1bjbj(q,j,q1,j1)
      temp T2bjbj(q,j,q1,j1)
      temp T3bjbj(q,j,q1,j1)
      temp Taibj(p,i,q,j)
      temp T1aibj(p,i,q,j)
      temp T2aibj(p,i,q,j)
      temp T3aibj(p,i,q,j)
      temp T4aibj(p,i,q,j)
      temp T5aibj(p,i,q,j)
#
      temp Txxxp(mu,nu,lambda,i)
      temp Txxxq(mu,nu,lambda,j)
      temp Txxpp(mu,nu,p1,i)
      temp Txxqq(mu,nu,q1,j)
      temp Txppp(mu,p2,p1,i)
      temp Txqpp(mu,q,p1,i)
      temp Txqqq(mu,q2,q1,j)
      temp Txpqq(mu,p,q1,j)
      temp Tpppp(p3,p2,p1,p)
      temp Tqqqq(q3,q2,q1,q)
      temp Tppqq(p1,p,q1,j)
      temp Tqqpp(q1,q,p1,i)
      temp Tixxx(i,mu,nu,sigma) 
      temp Tipxx(i,p,nu,sigma) 
      temp Tipqx(i,p,q,sigma) 
      temp Tipqq(i,p,q,q1) 
      temp Txiai(lambda,i,a1,i1) 
      temp Txjbj(lambda,j,b1,j1) 
      temp Txibj(lambda,i,b1,j1) 
#
      temp tmp1_aiai(a,i,a1,i1) 
      temp tmp2_aiai(a,i,a1,i1) 
      temp tmp3_aiai(a,i,a1,i1) 
      temp tmp1_aibj(a,i,b,j) 
      temp tmp2_aibj(a,i,b,j) 
#
      temp Tai(a,i) 
      temp T1ai(a,i) 
      temp T2ai(a,i) 
      temp T3ai(a,i) 
      temp Tbj(b,j) 
      temp T1bj(b,j) 
      temp T2bj(b,j) 
#
      temp Taa(a,a1) 
      temp T1aa(a,a1) 
      temp T1bb(b,b1) 
      temp Tae_a(a,a1) 
      temp Tae_b(b,b1) 
#
      temp Tia(i,a) 
      temp T1ia(i,a) 
      temp Tjb(j,b) 
      temp T1jb(j,b) 
      temp Tme_a(i,a) 
      temp Tme_b(j,b) 
#
      temp Tii(i,i1) 
      temp T1ii(i,i1) 
      temp Tjj(j,j1) 
      temp T1jj(j,j1) 
      temp Tmi_a(i,i1) 
      temp Tmi_b(j,j1) 
#
      temp T1pppp(p,p1,p2,p3) 
      temp T1qqqq(q,q1,q2,q3) 
      temp Taiii(a,i,i1,i2) 
      temp T1aiii(a,i,i1,i2) 
#
      temp  Tiiii(i,i1,i2,i3) 
      temp T1iiii(i,i1,i2,i3) 
#
      temp  Tjjjj(j,j1,j2,j3) 
      temp T1jjjj(j,j1,j2,j3) 
      temp  Tbjjj(b,j,j1,j2) 
      temp T1bjjj(b,j,j1,j2) 
#
      temp  Tiijj(i,i1,j2,j3) 
      temp T1iijj(i,i1,j2,j3) 
#
      temp  tmp_aa(a,a1) 
      temp tmp1_aa(a,a1) 
      temp  tmp_ii(i,i1) 
      temp tmp1_ii(i,i1) 
#
      temp  Tiiai(i,i1,a,i2) 
      temp T1iiai(i,i1,a,i2) 
#
      temp  tmp_bb(b,b1) 
      temp tmp1_bb(b,b1) 
      temp  tmp_jj(j,j1) 
      temp tmp1_jj(j,j1) 
#
      temp  Tjjbj(j,j1,b,j2) 
      temp T1jjbj(j,j1,b,j2) 
# 
      temp T1aaai(a,a1,a2,i)  
      temp T2aaai(a,a1,a2,i)  
      temp Taaaa(a,a1,a2,a3)  
      temp T1aaaa(a,a1,a2,a3)  
#
      temp T1bbbj(b,b1,b2,j)  
      temp T2bbbj(b,b1,b2,j)  
      temp Tbbbb(b,b1,b2,b3)  
      temp T1bbbb(b,b1,b2,b3)  
#
      temp Taabb(a,a1,b,b1)  
      temp T1aabb(a,a1,b,b1)  
#
      temp R1aiai(a,i,a1,i1) 
      temp R2aiai(a,i,a1,i1) 
      temp R3aiai(a,i,a1,i1) 
      temp R4aiai(a,i,a1,i1) 
      temp R1bjbj(b,j,b1,j1) 
      temp R2bjbj(b,j,b1,j1) 
      temp R3bjbj(b,j,b1,j1) 
      temp R4bjbj(b,j,b1,j1) 
      temp R1aibj(a,i,b,j) 
      temp R2aibj(a,i,b,j) 
      temp R3aibj(a,i,b,j) 
      temp R4aibj(a,i,b,j) 
#
      temp T1iaai(i,a,a1,i1) 
      temp T2iaai(i,a,a1,i1) 
      temp T1jbbj(j,b,b1,j1) 
      temp T2jbbj(j,b,b1,j1) 
      temp T1iabj(i,a,b,j) 
      temp T2iabj(i,a,b,j) 
      temp Tjjpp(j,j1,p,p1) 
      temp T1jjpp(j,j1,p,p1) 
      temp T2jjpp(j,j1,p,p1) 
      temp  Tiiqq(i,i1,q,q1) 
      temp T1iiqq(i,i1,q,q1) 
      temp T2iiqq(i,i1,q,q1) 
      temp  Tjjai(j,j1,a,i) 
      temp T1jjai(j,j1,a,i) 
      temp T2jjai(j,j1,a,i) 
      temp  Tiibj(i,i1,b,j) 
      temp T1iibj(i,i1,b,j) 
      temp T2iibj(i,i1,b,j) 
      temp  Tjbai(j,b,a,i)  
      temp T1jbai(j,b,a,i)  
      temp T2jbai(j,b,a,i)  
      temp  Taijj(a,i,j,j1) 
      temp T1aijj(a,i,j,j1) 
      temp Tqqip(a,i,b,b1)  
#
      temp tpx(p,mu) 
      temp t1px(p,mu) 
      temp tqx(q,mu) 
      temp t1qx(q,mu) 
      temp txi(mu,i) 
      temp t1xi(mu,i) 
      temp txj(mu,j) 
      temp t1xj(mu,j) 
#
# Declare distributed arrays 
# -------------------------- 
#
      served T2new_ab(a,i,b,j)
      served T2old_aa(a,i,a1,i1)
      served T2old_ab(a,i,b,j)
#
      served Tau_ab(a,i,b,j)
      served Taup_aa(a,i,a1,i1)
      served Taup_ab(a,i,b,j)
#
      served Wiibb(i1,i,b,b1)    
      served Wjjaa(j1,j,a,a1)      
#
# CIS
      scalar ecorr2
      scalar shift
      scalar rank
      scalar esum2
      scalar esum3
      scalar edoubles
      scalar etriples
      scalar ecis_d
      scalar kroot
#
      static Ek(kstate)
      static Ekd(kstate)
      static SCai(a,i)
#
      served M2old_ab(a,i,b,j)
      served ck0(kstate,a,i)
      served Cai(a,i)
      served Cai_ao(mu,i)
      served Faa(a,a1)
      served Fii(i,i1)
      served Fai(a,i)
      served SFai(a,i)
      served Ctau(a,i,b,j)
      served Ctau_ao(mu,i,lambda,j)
      served CT_ab(a,i,b,j)
#
      temp Tk(kstate)
      temp Tkai(kstate,a,i)
      temp T1kai(kstate,a,i)
      temp Tpp(p,p1)
      temp T1pp(p,p1)
      temp T2pp(p,p1)
#
# Declare served arrays 
# --------------------- 
#
      scalar ncount1
      scalar ncount2
      scalar jcount 
      scalar kcount 
      scalar niter 
      scalar diis_start 
      scalar diis_order  
      scalar temp_order
      scalar zero
      scalar one
      scalar two
      scalar five
      scalar six
      scalar seven
#
# Arrays needed for AOLADDER contribution
# ---------------------------------------
#
     temp Zab(lambda,i,b,j)
     temp Yab(lambda,i,mu,j)
     temp Y1ab(lambda,i,mu,j)
#
     temp TXaiai(a,i,nu,i1)
     temp Taixi(a,i,nu,i1)   
     temp TYaiai(a,i,a1,i1)
     temp TY1aiai(a,i,a1,i1)
     temp TXbjbj(b,j,nu,j1)
     temp Tbjxj(b,j,nu,j1)
     temp TYbjbj(b,j,b1,j1)
     temp TY1bjbj(b,j,b1,j1)
     temp TXaibj(a,i,nu,j)
     temp TZaibj(a,i,nu,j)
     temp Taixj(a,i,nu,j)
     temp T1aixj(a,i,nu,j)
     temp TYaibj(a,i,b,j)
#
     served TAO_ab(lambda,i,sigma,j)
     served T2AO_ab(lambda,i,sigma,j)
     distributed t1a_ax(a,mu) 
     distributed t1a_xi(mu,i) 
     distributed t1b_xj(mu,j) 
     served TDaixj(a,i,nu,j)
     local LDaixj(a,i,nu,j) 
#
      served Vxxxi(mu,nu,lambda,i)
      served Vxixi(mu,i1,lambda,i)
      served Vxxii(mu,nu,i1,i)
      served Vixxi(i1,nu,lambda,i)
      served Vxipi(mu,i,p,i1)
      served Vixai(i,mu,a,i1)
      served Vxaii(mu,a,i,i1)
      served Vxaai(mu,a1,a,i)
      served Vxxai(mu,nu,a,i)
      served Vxixj(mu,i,nu,j)
      served Vxiqj(mu,i,q,j)
      temp aoint(mu,nu,lambda,sigma)
      temp Txixi(mu,i1,lambda,i)
      temp Txxii(mu,nu,i1,i)
      temp Tixxi(i1,nu,lambda,i)
      temp Txipi(mu,i,p,i1)
      temp T1xipi(mu,i,p,i1)
      temp Tpipi(p1,i,p,i1)
      temp T1pipi(p1,i,p,i1)
      temp Tixai(i,mu,a,i1)
      temp Txaii(mu,a,i,i1)
      temp Tiaai(i,a1,a,i1)
      temp Taaii(a,a1,i,i1)
      temp Txaai(mu,a1,a,i)
      temp Taaai(a2,a,a1,i)
      temp Txxai(mu,nu,a,i)
      temp T1xaai(mu,a1,a,i) 
      temp T1xxxi(mu,nu,lambda,i)  
      temp T1xixi(mu,i,nu,i1)
      temp Txiix(mu,i,i1,nu)
      temp Txpii(mu,p,i,i1)
      temp Tppii(p,p1,i,i1)
      temp Tixpi(i,mu,p,i1)
      temp Tippi(i,p,p1,i1)
#
      local Lxxxi(mu,nu,lambda,i)
      local Lxxai(mu,nu,a,i) 
      local Lxaai(mu,a1,a,i) 
#
# Declare scalars 
# --------------- 
#
      scalar etemp
      scalar esum
      scalar esuma
      scalar esumb
      scalar esumab
      scalar ecorraa
      scalar ecorrbb
      scalar ecorrab
      scalar ecorrT
      scalar enew 
      scalar eold 
      scalar ecrit 
      scalar ediff 
      scalar mp2_energy
      scalar restart
#
# Arrays/Scalars used exclusively in DIIS procedure. 
# -------------------------------------------------- 
#
       served e1aibj(a,i,b,j)  
       served e2aibj(a,i,b,j)  
       served e3aibj(a,i,b,j)  
       served e4aibj(a,i,b,j)  
       served e5aibj(a,i,b,j)  
       served e6aibj(a,i,b,j)  
#
       served e5aiai(a,i,b,j) 
#
#    ------------------------------------------------------------------------ 
    PROC read_2el

    restore_persistent VSpipi "VSpipi"
    restore_persistent Vpiqj  "Vpiqj"
    restore_persistent Vaaii  "Vaaii"
    restore_persistent Viaai  "Viaai"
#

    ENDPROC read_2el
#
     PROC TRAN_TRAN2
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, lambda
#
          allocate Lxxxi(mu,nu,lambda,*)
#     
          DO sigma
#
             execute compute_integral_batch aoint(mu,nu,lambda,sigma)
#
             DO i   
#
                 T1xxxi(mu,nu,lambda,i)  = aoint(mu,nu,lambda,sigma)*ca(sigma,i)
                 Lxxxi(mu,nu,lambda,i)  += T1xxxi(mu,nu,lambda,i)
#    
             ENDDO i
#    
          ENDDO sigma

          DO i
           DO i1
              Txxii(mu,nu,i1,i)          = Lxxxi(mu,nu,lambda,i)*ca(lambda,i1)
              PREPARE Vxxii(mu,nu,i1,i) += Txxii(mu,nu,i1,i)
           ENDDO i1
           ENDDO i
#
          DO i
           DO i1
              Txixi(mu,i1,lambda,i)      = Lxxxi(mu,nu,lambda,i)*ca(nu,i1)
              PREPARE Vxixi(mu,i1,lambda,i) += Txixi(mu,i1,lambda,i)
           ENDDO i1
           ENDDO i
#
          DO i
           DO i1
              Tixxi(i1,nu,lambda,i)      = Lxxxi(mu,nu,lambda,i)*ca(mu,i1)
              PREPARE Vixxi(i1,nu,lambda,i) += Tixxi(i1,nu,lambda,i)
           ENDDO i1
           ENDDO i
#    
##          DO i
#           DO a
#              Txxai(mu,nu,a,i)          = Lxxxi(mu,nu,lambda,i)*ca(lambda,a)
#              PREPARE Vxxai(mu,nu,a,i) += Txxai(mu,nu,a,i)
#           ENDDO a
#           ENDDO i
#
          deallocate Lxxxi(mu,nu,lambda,*)
#
     ENDPARDO mu, nu, lambda
     server_barrier
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_TRAN2
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
#    Perform the third N5 stage of the transformation.
#
     PROC TRAN_TRAN3
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, i, i1
#
           REQUEST Vxixi(mu,i,nu,i1) i1
#
           DO p
#
              Txipi(mu,i,p,i1)          = Vxixi(mu,i,nu,i1)*ca(nu,p)
              PREPARE Vxipi(mu,i,p,i1) += Txipi(mu,i,p,i1)
#
           ENDDO p
#
     ENDPARDO mu, nu, i, i1
#
     PARDO mu, nu, i, i1
#
           REQUEST Vxxii(mu,nu,i,i1) i1
#
           DO a
#
              Txaii(mu,a,i,i1)          = Vxxii(mu,nu,i,i1)*ca(nu,a)
              PREPARE Vxaii(mu,a,i,i1) += Txaii(mu,a,i,i1)

           ENDDO a
#
     ENDPARDO mu, nu, i, i1
#
     PARDO mu, nu, i, i1
#
           REQUEST Vixxi(i,mu,nu,i1) i1
#
           DO a
#
              Tixai(i,mu,a,i1)          = Vixxi(i,mu,nu,i1)*ca(nu,a)
              PREPARE Vixai(i,mu,a,i1) += Tixai(i,mu,a,i1)
#
           ENDDO a

     ENDPARDO mu, nu, i, i1
#
#     pardo mu,nu,a,i
#         request Vxxai(mu,nu,a,i) i
#         do a1
##             Txaai(mu,a1,a,i) = Vxxai(mu,nu,a,i)*Ca(nu,a1)
#             prepare Vxaai(mu,a1,a,i) += Txaai(mu,a1,a,i)
#         enddo a1
#     endpardo mu,nu,a,i
#
#    ------------------------------------------------------------------------
#
     server_barrier
#
     ENDPROC TRAN_TRAN3
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_TRAN4
#
#    ------------------------------------------------------------------------
#
     PARDO mu, p, i, i1
#
           REQUEST             Vxipi(mu,i,p,i1) i1
           REQUEST             Vxipi(mu,i1,p,i) i
           Txipi(mu,i,p,i1)  = Vxipi(mu,i,p,i1)
           T1xipi(mu,i,p,i1) = Vxipi(mu,i1,p,i)
           Txipi(mu,i,p,i1) -= T1xipi(mu,i,p,i1)
#
           DO p1
#
              Tpipi(p1,i,p,i1)          = Vxipi(mu,i,p,i1)*ca(mu,p1)
              PREPARE Vpiqj(p1,i,p,i1) += Tpipi(p1,i,p,i1)
#
           ENDDO p1
#
           DO p1
#
              Tpipi(p1,i,p,i1)          = Txipi(mu,i,p,i1)*ca(mu,p1)
              PREPARE VSpipi(p1,i,p,i1) += Tpipi(p1,i,p,i1)
#
           ENDDO p1
#
     ENDPARDO mu, p, i, i1
#
     PARDO mu, a, i, i1
#
           REQUEST Vxaii(mu,a,i,i1) i1
           REQUEST Vixai(i,mu,a,i1) i1
#
           DO a1
#
              Taaii(a1,a,i,i1)          = Vxaii(mu,a,i,i1)*ca(mu,a1)
              PREPARE Vaaii(a1,a,i,i1) += Taaii(a1,a,i,i1)
#
           ENDDO a1
#
           DO a1
#
              Tiaai(i,a1,a,i1)          = Vixai(i,mu,a,i1)*ca(mu,a1)
              PREPARE Viaai(i,a1,a,i1) += Tiaai(i,a1,a,i1)
#
           ENDDO a1
#
     ENDPARDO mu, a, i, i1
#
#         pardo mu, a, a1, i
#             request Vxaai(mu,a,a1,i) i
#             do a2
#                 Taaai(a2,a,a1,i) = Vxaai(mu,a,a1,i)*Ca(mu,a2)
#                 prepare Vaaai(a2,a,a1,i) += Taaai(a2,a,a1,i)
#             enddo a2
#         endpardo mu, a, a1, i

         server_barrier
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_TRAN4
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_UHF
#
#        CALL COMP_INTEGRALS # --> compute integrals and put into served array
         CALL TRAN_TRAN2     # --> performs the first two stages of the
                             #     two-electron integral transformation.
         CALL TRAN_TRAN3     # --> performs the third stage
                             #     two-electron integral transformation.
         CALL TRAN_TRAN4     # --> performs the fourth stage of the
                             #     two-electron integral transformation.
#
     ENDPROC TRAN_UHF
#
      proc setroot
#
      Tk(kstate) = 1.0
      do a
      do i
          request ck0(kstate,a,i) i
          Tai(a,i) = ck0(kstate,a,i)*Tk(kstate)
          SCai(a,i) = Tai(a,i)
      enddo i
      enddo a
      server_barrier
      endproc setroot
#
#    ------------------------------------------------------------------------ 
    PROC IGUESS_UHF
    pardo a,b,i,j
#
        request M2old_ab(a,i,b,j) j
        Taibj(a,i,b,j) = M2old_ab(a,i,b,j)
        prepare T2old_ab(a,i,b,j) = Taibj(a,i,b,j)
        prepare D0aibj(a,i,b,j) = Taibj(a,i,b,j)
#
    endpardo a,b,i,j
    server_barrier
    pardo a,i,b,j
         request T2old_ab(a,i,b,j) j
         request T2old_ab(a,j,b,i) i
         Taibj(a,i,b,j)  = T2old_ab(a,i,b,j)
         T1aibj(a,i,b,j) = T2old_ab(a,j,b,i)
         Taibj(a,i,b,j) -= T1aibj(a,i,b,j)
         prepare T2old_aa(a,i,b,j) = Taibj(a,i,b,j)
     endpardo a,i,b,j
     server_barrier
#
    ENDPROC IGUESS_UHF
#
    PROC energy
#
    ecorrab = 0.0
    esumab  = 0.0
    server_barrier
    pardo a,i,b,j
#
        request Vpiqj(a,i,b,j) j
        request Vpiqj(a,j,b,i) j
#
        request T2old_ab(a,i,b,j) j
        Taibj(a,i,b,j) = T2old_ab(a,i,b,j)
#
        T1aibj(a,i,b,j)  = Vpiqj(a,i,b,j)
        T2aibj(a,i,b,j)  = Vpiqj(a,j,b,i)
        T1aibj(a,i,b,j) *= 2.0
        T1aibj(a,i,b,j) -= T2aibj(a,i,b,j)
#
        etemp = Taibj(a,i,b,j)*T1aibj(a,i,b,j)
        esumab += etemp
#
    endpardo a,i,b,j
    server_barrier
#
    collective ecorrab += esumab
    ecorrT = ecorrab
    ecorrT += ecis_d
    print_scalar ecorrT
#
    server_barrier
    ENDPROC energy
#
#
     proc Caibj
#
     pardo a,i,b,j
         Taiai(a,i,b,j) = 0.0
         prepare Ctau(a,i,b,j) = Taiai(a,i,b,j)
         prepare CT_ab(a,i,b,j) = Taiai(a,i,b,j)
     endpardo a,i,b,j
     pardo mu,i
         Txi(mu,i) = 0.0
         prepare Cai_ao(mu,i) = Txi(mu,i)
     endpardo mu,i
     pardo mu,i,lambda,j
         Txixi(mu,i,lambda,j) = 0.0
         prepare Ctau_ao(mu,i,lambda,j) = Txixi(mu,i,lambda,j)
     endpardo mu,i,lambda,j
     server_barrier
#
# back transform CIS vector
     pardo a,i
#         request Cai(a,i) i
         do mu
             Txi(mu,i) = SCai(a,i)*ca(mu,a)
             prepare Cai_ao(mu,i) += Txi(mu,i)
         enddo mu
     endpardo a,i
#
     server_barrier
#
     pardo mu,nu,lambda

          allocate Lxxxi(mu,nu,lambda,*)
          DO sigma
             execute compute_integral_batch aoint(mu,nu,lambda,sigma)
             DO i   
                 T1xxxi(mu,nu,lambda,i)  = aoint(mu,nu,lambda,sigma)*ca(sigma,i)
                 Lxxxi(mu,nu,lambda,i)  += T1xxxi(mu,nu,lambda,i)
             ENDDO i
          ENDDO sigma

          do i
              request Cai_ao(nu,i) i
          do j

              Txixi(mu,i,lambda,j) = Cai_ao(nu,i)*Lxxxi(mu,nu,lambda,j)
              prepare Ctau_ao(mu,i,lambda,j) += Txixi(mu,i,lambda,j)

          enddo j
          enddo i

          deallocate Lxxxi(mu,nu,lambda,*)

     endpardo mu,nu,lambda
#
     server_barrier
     pardo a,i,b,j
         Taiai(a,i,b,j) = 0.0
         do i1
             request Vpiqj(i1,i,b,j) j
#             request cai(a,i1) a
             T1aiai(a,i,b,j) = Vpiqj(i1,i,b,j)*SCai(a,i1)
             Taiai(a,i,b,j) += T1aiai(a,i,b,j)
         enddo i1
         Taiai(a,i,b,j) *= -1.0
         prepare Ctau(a,i,b,j) += Taiai(a,i,b,j)
     endpardo a,i,b,j

     pardo nu,i,j

              allocate LDaixj(*,i,nu,j)
#
              DO mu
#
                 REQUEST Ctau_ao(mu,i,nu,j) j
#
                 DO a
                    Taixj(a,i,nu,j)   = Ctau_ao(mu,i,nu,j)*ca(mu,a)
                    LDaixj(a,i,nu,j) += Taixj(a,i,nu,j)
                 ENDDO a
#
              ENDDO mu

              DO a
              DO b
                 Taibj(a,i,b,j)             = LDaixj(a,i,nu,j)*ca(nu,b)
                 PREPARE Ctau(a,i,b,j) += Taibj(a,i,b,j)
              ENDDO b
              ENDDO a
#
              deallocate LDaixj(*,i,nu,j)

     endpardo nu,i,j

     server_barrier
     pardo a,i,b,j
         request Ctau(a,i,b,j) j
         request Ctau(b,j,a,i) i
         Taiai(a,i,b,j)  = Ctau(a,i,b,j)
         T1aiai(a,i,b,j) = Ctau(b,j,a,i)
         Taiai(a,i,b,j) += T1aiai(a,i,b,j)
         prepare CT_ab(a,i,b,j) = Taiai(a,i,b,j)
     endpardo a,i,b,j
     server_barrier
     pardo a,i,b,j
         request CT_ab(a,i,b,j) j
         Taibj(a,i,b,j) = CT_ab(a,i,b,j)
         execute energy_denominator_rhf Taibj(a,i,b,j) fock_a
         prepare T2old_ab(a,i,b,j) += Taibj(a,i,b,j)
         prepare D0aibj(a,i,b,j) += Taibj(a,i,b,j)
     endpardo a,i,b,j
     server_barrier
#
     endproc Caibj
#
     proc hbar_ab
#
     pardo a,i,b,j
#
         Tpp(a,b) = 0.0
         do a1
             request VSpipi(b,i,a1,j) j
             request T2old_aa(a,i,a1,j) j
             T1pp(a,b) = VSpipi(b,i,a1,j)*T2old_aa(a,i,a1,j)
             Tpp(a,b) += T1pp(a,b)
         enddo a1
         Tpp(a,b) *= -0.5
         prepare Faa(a,b) += Tpp(a,b)
#
     endpardo a,i,b,j
     pardo a,i,b,j
#
         Tpp(a,b) = 0.0
         do a1
             request Vpiqj(b,i,a1,j) j
             request T2old_ab(a,i,a1,j) j
             T1pp(a,b) = Vpiqj(b,i,a1,j)*T2old_ab(a,i,a1,j)
             Tpp(a,b) += T1pp(a,b)
         enddo a1
         Tpp(a,b) *= -1.0
         prepare Faa(a,b) += Tpp(a,b)
#
     endpardo a,i,b,j
#
     server_barrier
     endproc hbar_ab
#
     proc hbar_ij
#
     pardo a,i,b,j
#
         Tpp(i,j) = 0.0
         do i1
             request VSpipi(a,j,b,i1) i1
             request T2old_aa(a,i,b,i1) i1
             T1pp(i,j) = VSpipi(a,j,b,i1)*T2old_aa(a,i,b,i1)
             Tpp(i,j) += T1pp(i,j)
         enddo i1
         Tpp(i,j) *= -0.5
         prepare Fii(i,j) += Tpp(i,j)
#
     endpardo a,i,b,j
     pardo a,i,b,j
#
         Tpp(i,j) = 0.0
         do i1
             request Vpiqj(a,j,b,i1) i1
             request T2old_ab(a,i,b,i1) i1
             T1pp(i,j) = Vpiqj(a,j,b,i1)*T2old_ab(a,i,b,i1)
             Tpp(i,j) += T1pp(i,j)
         enddo i1
         Tpp(i,j) *= -1.0
         prepare Fii(i,j) += Tpp(i,j)
#
     endpardo a,i,b,j
#
     server_barrier
     endproc hbar_ij
#
     proc hbar_ai

     pardo a,i,a1,i1
         request VSpipi(a,i,a1,i1) i1

         Taibj(a,i,a1,i1) = VSpipi(a,i,a1,i1)
         T1pp(a1,i1)      = SCai(a1,i1)
         Tpp(a,i)         = Taibj(a,i,a1,i1)*T1pp(a1,i1)

         prepare SFai(a,i) += Tpp(a,i)
     endpardo a,i,a1,i1
     pardo a,i,a1,i1
         request Vpiqj(a,i,a1,i1) i1

         Taibj(a,i,a1,i1) = Vpiqj(a,i,a1,i1)
         T1pp(a1,i1)      = SCai(a1,i1)
         Tpp(a,i)         = Taibj(a,i,a1,i1)*T1pp(a1,i1)

         prepare SFai(a,i) += Tpp(a,i)
     endpardo a,i,a1,i1
     server_barrier
     pardo a,i,a1,i1
         request T2old_aa(a,i,a1,i1) i1
         request SFai(a1,i1) i
         Taibj(a,i,a1,i1) = T2old_aa(a,i,a1,i1)
         T1pp(a1,i1)      = SFai(a1,i1)
         Tpp(a,i)         = Taibj(a,i,a1,i1)*T1pp(a1,i1)
         prepare Fai(a,i) += Tpp(a,i)
     endpardo a,i,a1,i1
     pardo a,i,a1,i1
         request T2old_ab(a,i,a1,i1) i1
         request SFai(a1,i1) i
         Taibj(a,i,a1,i1) = T2old_ab(a,i,a1,i1)
         T1pp(a1,i1)      = SFai(a1,i1)
         Tpp(a,i)         = Taibj(a,i,a1,i1)*T1pp(a1,i1)
         prepare Fai(a,i) += Tpp(a,i)
     endpardo a,i,a1,i1
     server_barrier
#
     endproc hbar_ai
#
     proc hbar_prep
         server_barrier
         pardo a,b
             Tpp(a,b) = 0.0
             prepare Faa(a,b) = Tpp(a,b)
         endpardo a,b
         pardo i,j
             Tpp(i,j) = 0.0
             prepare Fii(i,j) = Tpp(i,j)
         endpardo i,j
         pardo a,i
             Tpp(a,i) = 0.0
             prepare Fai(a,i) = Tpp(a,i)
         endpardo a,i
         pardo a,i
             Tpp(a,i) = 0.0
             prepare SFai(a,i) = Tpp(a,i)
         endpardo a,i
         server_barrier
     endproc hbar_prep
#
     proc make_hbar
#
     call hbar_prep
     call hbar_ab
     call hbar_ij
     call hbar_ai
     server_barrier
#
     endproc make_hbar
#
     proc cisd_energy
#
     server_barrier
     esum2 = 0.0
     esum3 = 0.0
     ecorr2 = 0.0
     edoubles = 0.0
     etriples = 0.0
     ecis_d = 0.0
     server_barrier
#
     pardo a,i,b,j
         request T2old_ab(a,i,b,j) j
         REQUEST CT_ab(a,i,b,j) j
         REQUEST CT_ab(b,i,a,j) j
         Taibj(a,i,b,j)  = CT_ab(a,i,b,j)
         T1aibj(a,i,b,j) = CT_ab(b,i,a,j)
         Taibj(a,i,b,j) *= 2.0
         Taibj(a,i,b,j) -= T1aibj(a,i,b,j)
#
         etemp  = Taibj(a,i,b,j)*T2old_ab(a,i,b,j)
         etemp *= 0.5
         esum2 += etemp
     endpardo a,i,b,j
     pardo a,i
#         request cai(a,i) i
         request Fai(a,i) i
         Tpp(a,i) = Fai(a,i)
#
         do b
             request Faa(a,b) a
#             request cai(b,i) i
             T1pp(a,i) = Faa(a,b)*SCai(b,i)
             Tpp(a,i) += T1pp(a,i)
         enddo b
#
         do j
             request Fii(i,j) i
#             request cai(a,j) a
             T1pp(a,i) = Fii(i,j)*SCai(a,j)
             Tpp(a,i) += T1pp(a,i)
         enddo j
#
         etemp = SCai(a,i)*tpp(a,i)
         esum3+= etemp
#
     endpardo a,i
     server_barrier
#
     collective edoubles += esum2
     collective etriples += esum3
     server_barrier
     ecis_d  = edoubles
     ecis_d += etriples
     Ekd(kstate) = ecis_d
     execute get_my_rank rank
     if rank == 0.0
         print_scalar edoubles
         print_scalar etriples
         print_scalar ecis_d
     endif #rank == 0.0
#
     endproc cisd_energy
#    ------------------------------------------------------------------------ 
# AA t2 amps
    PROC T2oldaa
#
    pardo a,i,b,j
        request T2old_ab(a,i,b,j) a
        request T2old_ab(a,j,b,i) a
        T1aibj(a,i,b,j)  = T2old_ab(a,i,b,j)
        T2aibj(a,i,b,j)  = T2old_ab(a,j,b,i)
        T1aibj(a,i,b,j) -= T2aibj(a,i,b,j)
        prepare T2old_aa(a,i,b,j) = T1aibj(a,i,b,j)
    endpardo a,i,b,j
    server_barrier
#
    ENDPROC T2oldaa
#    ------------------------------------------------------------------------ 
    proc t2new_zero
#
    pardo a,i,b,j
        Taibj(a,i,b,j) = 0.0
        prepare T2new_ab(a,i,b,j) = Taibj(a,i,b,j)
    endpardo a,i,b,j
    server_barrier
#
    endproc t2new_zero
#    ------------------------------------------------------------------------ 
    proc T2newab
#
    pardo a,b,i,j
#
        request Vpiqj(a,i,b,j) j
        Taibj(a,i,b,j)  = Vpiqj(a,i,b,j)
        Taibj(a,i,b,j) *= 0.5
        T1aibj(b,j,a,i) = Taibj(a,i,b,j)
        prepare T2new_ab(a,i,b,j) += Taibj(a,i,b,j)
        prepare T2new_ab(b,j,a,i) += T1aibj(b,j,a,i)
#
    endpardo a,b,i,j
    pardo a,i,b,j
        request CT_ab(a,i,b,j) j
        Taibj(a,i,b,j) = CT_ab(a,i,b,j)
        prepare T2new_ab(a,i,b,j) += Taibj(a,i,b,j)
    endpardo a,i,b,j
#
    endproc T2newab
#    ------------------------------------------------------------------------ 
    proc hhladder_ab
#
    pardo a,b,i1,j1
        request T2old_ab(a,i1,b,j1) j1
        do i
            do j
                request Vpiqj(i,i1,j,j1) j
                Taibj(a,i,b,j) = T2old_ab(a,i1,b,j1)*Vpiqj(i,i1,j,j1)
                prepare T2new_ab(a,i,b,j) += Taibj(a,i,b,j)
            enddo j
        enddo i
    endpardo a,b,i1,j1
#
    endproc hhladder_ab
#    ------------------------------------------------------------------------ 
    proc AOppladder_ab

#    First create and zero-out intermediate arrays
#    ---------------------------------------------
#
     PARDO mu, nu, i, j
           Txixj(mu,i,nu,j)           = 0.0
           PREPARE TAO_ab(mu,i,nu,j)  = Txixj(mu,i,nu,j)
           PREPARE T2AO_ab(mu,i,nu,j) = Txixj(mu,i,nu,j)
     ENDPARDO mu, nu, i, j
#
     server_barrier 
#
#    Form Half back transformed cluster arrays  
#    -----------------------------------------
#
#    AB spin combination
#     -------------------
#
     PARDO b, a, j, i
#
           REQUEST T2old_ab(a,i,b,j) a
#
           DO mu
#
              Taixj(a,i,mu,j) = T2old_ab(a,i,b,j)*ca(mu,b)
#
              DO nu
#
                 Txixj(nu,i,mu,j)           = Taixj(a,i,mu,j)*ca(nu,a)
                 PREPARE TAO_ab(nu,i,mu,j) += Txixj(nu,i,mu,j)
#
              ENDDO nu
#
           ENDDO mu
#
      ENDPARDO b, a, j, i
#
     server_barrier   
#
#    Contract AOINT with half back transformed Amplitudes 
#    ----------------------------------------------------    
#
     PARDO mu, nu, lambda, sigma
        WHERE mu < nu 
#
           execute compute_integral_batch aoint(lambda,mu,sigma,nu) 
#
           DO i
           DO j
#
              REQUEST                       TAO_ab(lambda,i,sigma,j) j
              Yab(mu,i,nu,j)              = aoint(lambda,mu,sigma,nu)*TAO_ab(lambda,i,sigma,j)
              Y1ab(nu,j,mu,i)             = Yab(mu,i,nu,j)
#
              PREPARE T2AO_ab(mu,i,nu,j) += Yab(mu,i,nu,j)
              PREPARE T2AO_ab(nu,j,mu,i) += Y1ab(nu,j,mu,i)
#
           ENDDO j
           ENDDO i
#
     ENDPARDO mu, nu, lambda, sigma
#
     PARDO mu, nu, lambda, sigma
        WHERE mu == nu 
#
           execute compute_integral_batch aoint(lambda,mu,sigma,nu) 
#
           DO i
           DO j
#
              REQUEST                       TAO_ab(lambda,i,sigma,j) j
              Yab(mu,i,nu,j)              = aoint(lambda,mu,sigma,nu)*TAO_ab(lambda,i,sigma,j)
              PREPARE T2AO_ab(mu,i,nu,j) += Yab(mu,i,nu,j)
#
           ENDDO j
           ENDDO i
#
     ENDPARDO mu, nu, lambda, sigma
#
     server_barrier  
#
#    Perform final transformation
#    ----------------------------
#
        PARDO nu, i, j
#
              allocate LDaixj(*,i,nu,j)
#
              DO mu
#
                 REQUEST T2AO_ab(mu,i,nu,j) j
#
                 DO a
                    Taixj(a,i,nu,j)   = T2AO_ab(mu,i,nu,j)*ca(mu,a)
                    LDaixj(a,i,nu,j) += Taixj(a,i,nu,j)
                 ENDDO a
#
              ENDDO mu
#
              DO a
                 PREPARE TDaixj(a,i,nu,j) = LDaixj(a,i,nu,j)
              ENDDO a
#
              deallocate LDaixj(*,i,nu,j)
#
        ENDPARDO nu, i, j
        server_barrier
#
        PARDO a, i, j, nu
#
              REQUEST TDaixj(a,i,nu,j) a
#
              DO b
#
                 Taibj(a,i,b,j)             = TDaixj(a,i,nu,j)*ca(nu,b)
#
                 PREPARE T2new_ab(a,i,b,j) += Taibj(a,i,b,j)
#
              ENDDO b
#
        ENDPARDO a, i, j, nu
#
        sip_barrier
    endproc AOppladder_ab
#
#    ------------------------------------------------------------------------ 
    proc phladder_ab
#
      PARDO j, b, a, i
            Taibj(a,i,b,j) = 0.0
#
            DO i1
            DO a1
#
               REQUEST              Viaai(i,a,a1,i1) i
               REQUEST              Vaaii(a1,a,i,i1) i
               REQUEST              T2old_ab(a1,i1,b,j) j

               TYaiai(a,i,a1,i1)   = 0.0
#
               Taiai(a,i,a1,i1)    = Vaaii(a1,a,i,i1)
               TYaiai(a,i,a1,i1)  -= Taiai(a,i,a1,i1)
               Taiai(a,i,a1,i1)    = Viaai(i,a,a1,i1)
               TYaiai(a,i,a1,i1)  += Taiai(a,i,a1,i1)
#
               R1aibj(a,i,b,j)     = TYaiai(a,i,a1,i1)*T2old_ab(a1,i1,b,j)
               Taibj(a,i,b,j)     += R1aibj(a,i,b,j)
#
            ENDDO a1
            ENDDO i1

            R1aibj(b,j,a,i)            = taibj(a,i,b,j)
            PREPARE T2new_ab(a,i,b,j) += taibj(a,i,b,j)
            PREPARE T2new_ab(b,j,a,i) += R1aibj(b,j,a,i)
#
      ENDPARDO j, b, a, i
#
      PARDO i1, a1, a, i
            REQUEST                     T2old_ab(a1,i1,a,i) a
            REQUEST                     T2old_ab(a1,i,a,i1) a
            taiai(a1,i1,a,i)          = T2old_ab(a1,i1,a,i)
            t1aiai(a1,i1,a,i)         = T2old_ab(a1,i,a,i1)
            taiai(a1,i1,a,i)         -= t1aiai(a1,i1,a,i)
            tpppp(a1,i1,i,a)          = taiai(a1,i1,a,i)
#
            DO j
            DO b
#
               REQUEST                        Viaai(i,a,b,j) j
               R1aibj(a1,i1,b,j)            = tpppp(a1,i1,i,a)*Viaai(i,a,b,j)
               Taibj(b,j,a1,i1)             = R1aibj(a1,i1,b,j)
               PREPARE T2new_ab(a1,i1,b,j) += R1aibj(a1,i1,b,j)
               PREPARE T2new_ab(b,j,a1,i1) += Taibj(b,j,a1,i1)
#
            ENDDO b
            ENDDO j
#
      ENDPARDO i1, a1, a, i
#
      PARDO a, j, i1, b1
#
            REQUEST T2old_ab(a,i1,b1,j) j
#
            DO i
            DO b
#
               REQUEST                      Vaaii(b,b1,i1,i) i
#
               Taibj(a,i,b,j)             = T2old_ab(a,i1,b1,j)*Vaaii(b,b1,i1,i)
               Taibj(a,i,b,j)            *= -1.0
#
               T2aibj(b,j,a,i)            = Taibj(a,i,b,j)
               PREPARE T2new_ab(a,i,b,j) += Taibj(a,i,b,j)
               PREPARE T2new_ab(b,j,a,i) += T2aibj(b,j,a,i)
#
            ENDDO b
            ENDDO i
#
      ENDPARDO a, j, i1, b1
#
    endproc phladder_ab
#    ------------------------------------------------------------------------ 
#    ------------------------------------------------------------------------ 
#    ------------------------------------------------------------------------ 
#    ------------------------------------------------------------------------ 
    proc updatet2
#
      PARDO b, a, j, i
#
            REQUEST                    T2old_ab(b,j,a,i) b
            REQUEST                    T2new_ab(b,j,a,i) b
            Taibj(a,i,b,j)           = T2new_ab(b,j,a,i)
            T1aibj(a,i,b,j)          = T2old_ab(b,j,a,i)
#
            REQUEST                    T2old_ab(a,i,b,j) b
            REQUEST                    T2new_ab(a,i,b,j) b
            Taibj(a,i,b,j)          += T2new_ab(a,i,b,j)
            T1aibj(a,i,b,j)         += T2old_ab(a,i,b,j)

            execute energy_denominator_rhf Taibj(a,i,b,j) fock_a
            T1aibj(a,i,b,j) -= Taibj(a,i,b,j)
            T1aibj(a,i,b,j) *= -0.5

            if niter < diis_order
               PREPARE Eaibj(a,i,b,j,kiter) = T1aibj(a,i,b,j)
            endif

            if niter >= diis_order
               kcount = 0.0
               DO jdiis
                  kcount += 1.0
                  if kcount == diis_order
                     PREPARE Eaibj(a,i,b,j,jdiis) = T1aibj(a,i,b,j)
                     exit
                  endif
               ENDDO jdiis
            endif
      ENDPARDO b, a, j, i
      server_barrier
#
      PARDO b, a, j, i
#
            REQUEST                    T2new_ab(a,i,b,j) a
            REQUEST                    T2new_ab(b,j,a,i) a
            Taibj(a,i,b,j)           = T2new_ab(b,j,a,i)
            Taibj(a,i,b,j)          += T2new_ab(a,i,b,j)
            Taibj(a,i,b,j)          *= 0.5
            execute energy_denominator_rhf Taibj(a,i,b,j) fock_a
            PREPARE T2old_ab(a,i,b,j)    = Taibj(a,i,b,j)
#
      ENDPARDO b, a, j, i
#
    endproc updatet2
#    ------------------------------------------------------------------------ 
      PROC DIISN
#     ---------- 

      create DIST_BB
      worder = niter
      if niter >= diis_order
         worder = diis_order
      endif
      server_barrier
      PARDO a, i, b, j
         kcount = 0.0
         DO jdiis
            kcount += 1.0
            if kcount <= worder

               REQUEST Eaibj(a,i,b,j,jdiis) a
               REQUEST Eaibj(a,j,b,i,jdiis) a

               t1aibj(a,i,b,j) = Eaibj(a,i,b,j,jdiis)
               t3aibj(a,j,b,i) = Eaibj(a,j,b,i,jdiis)
               t2aibj(a,i,b,j) = t3aibj(a,j,b,i)
               t1aibj(a,i,b,j)-= t2aibj(a,i,b,j)

         jcount = 0.0
         DO j1diis
            jcount += 1.0
            if jcount <= worder

               REQUEST Eaibj(a,i,b,j,j1diis) a
               REQUEST Eaibj(a,j,b,i,j1diis) a

               t3aibj(a,i,b,j) = Eaibj(a,i,b,j,j1diis)
               t2aibj(a,j,b,i) = Eaibj(a,j,b,i,j1diis)
               t4aibj(a,i,b,j) = t2aibj(a,j,b,i)
               t3aibj(a,i,b,j)-= t4aibj(a,i,b,j)

               tbb(jdiis,j1diis)          = Eaibj(a,i,b,j,jdiis)*Eaibj(a,i,b,j,j1diis)
               tbb(jdiis,j1diis)         *= 2.0
               PUT DIST_BB(jdiis,j1diis) += tbb(jdiis,j1diis)

               etemp                     = t1aibj(a,i,b,j)*t3aibj(a,i,b,j)
               tbb(jdiis,j1diis)          = etemp
               PUT DIST_BB(jdiis,j1diis) += tbb(jdiis,j1diis)
            endif
         ENDDO j1diis
            endif # kcount <= diis_order  
         ENDDO jdiis
      ENDPARDO a, i, b, j
      server_barrier

      jcount = 0.0
      DO jdiis
         jcount += 1.0
         if jcount <= worder
      kcount = 0.0
      DO j1diis
         kcount += 1.0
         if kcount <= worder
            GET DIST_BB(jdiis,j1diis)
            BB(jdiis,j1diis) = DIST_BB(jdiis,j1diis)
         endif
      ENDDO j1diis
         endif
      ENDDO jdiis
     #println "finished coputing BB" 

      execute compute_diis BB
      temp_order = worder
     #if worder > diis_order 
     #   temp_order = diis_order 
     #endif 
      server_barrier
     #println "finished compute_diis" 
     #DO jdiis 
     #execute print_block BB(jdiis,jdiis) 
     #ENDDO jdiis 
      PARDO a, i, b, j
            taibj(a,i,b,j) = 0.0
            n1 = 0.0
            DO kdiis
               n1 += 1.0
               if n1 <  worder # temp_order # VFL  
                  REQUEST           Daibj(a,i,b,j,kdiis) a
                  t2aibj(a,i,b,j) = Daibj(a,i,b,j,kdiis)
                  n2 = 0.0
                  DO d2
                    n2 += 1.0
                    if n2 <= worder
                      kcount  = n2
                      kcount -= n1
                      if kcount == one
                         REQUEST           Eaibj(a,i,b,j,d2) a
                         t3aibj(a,i,b,j) = Eaibj(a,i,b,j,d2)
                         execute return_sval BB(d2,d2) etemp
                        #etemp        = BB(d1,d1)        
                         t3aibj(a,i,b,j) += t2aibj(a,i,b,j)
                         t3aibj(a,i,b,j) *= etemp
                         taibj(a,i,b,j)  += t3aibj(a,i,b,j)
                      endif
                    endif #n2 <= worder 
                   ENDDO d2
               endif
            ENDDO kdiis

            n2 = 0.0
            DO d2
               n2 += 1.0
               if n2 == one
                  REQUEST           D0aibj(a,i,b,j) a
                  t2aibj(a,i,b,j) = D0aibj(a,i,b,j)
                  REQUEST           Eaibj(a,i,b,j,d2) a
                  t3aibj(a,i,b,j) = Eaibj(a,i,b,j,d2)
                  execute return_sval BB(d2,d2) etemp
                 #etemp        = BB(d1,d1)        
                  t3aibj(a,i,b,j) += t2aibj(a,i,b,j)
                  t3aibj(a,i,b,j) *= etemp
                  taibj(a,i,b,j)  += t3aibj(a,i,b,j)
               endif
            ENDDO d2

            PREPARE T2old_ab(a,i,b,j) = taibj(a,i,b,j)
      ENDPARDO a, i, b, j
      server_barrier

# If history space is full shift history end error vectors 

      if niter >= diis_order

# histories first 

      PARDO a, i, b, j
      n1 = 0.0
      DO kdiis
         n1 += 1.0
         if n1 <  worder # temp_order # VFL 
         REQUEST Daibj(a,i,b,j,kdiis) a
         taibj(a,i,b,j) = Daibj(a,i,b,j,kdiis)
         n2 = 0.0
      DO k1diis
         n2 += 1.0
         etemp = n1
         etemp -= n2
         if etemp == 1.0
            PREPARE Daibj(a,i,b,j,k1diis) = taibj(a,i,b,j)
         endif
         if n1 == one
            PREPARE D0aibj(a,i,b,j) = taibj(a,i,b,j)
         endif
      ENDDO k1diis
         endif
      ENDDO kdiis
      ENDPARDO a, i, b, j
# Now error vectors 

      PARDO a, i, b, j
      n1 = 0.0
      DO kdiis
         n1 += 1.0
         if n1 <= worder # temp_order # VFL 
         REQUEST Eaibj(a,i,b,j,kdiis) a
         taibj(a,i,b,j) = Eaibj(a,i,b,j,kdiis)
         n2 = 0.0
      DO k1diis
         n2 += 1.0
         etemp = n1
         etemp -= n2
         if etemp == 1.0
            PREPARE Eaibj(a,i,b,j,k1diis) = taibj(a,i,b,j)
         endif
      ENDDO k1diis
         endif
      ENDDO kdiis
      ENDPARDO a, i, b, j


      endif
      server_barrier
      delete DIST_BB

      ENDPROC DIISN
#
      proc clear_diis
#
      do d1
      do d2
          Tbb(d1,d2) = 0.0
          BB(d1,d2) = 0.0
      enddo d2
      enddo d1
      pardo a,i,b,j
          Taibj(a,i,b,j) = 0.0
          prepare D0aibj(a,i,b,j) = Taibj(a,i,b,j)
      endpardo a,i,b,j
      pardo a,i,b,j,kdiis
          Taibjk(a,i,b,j,kdiis) = 0.0
          prepare Daibj(a,i,b,j,kdiis) = Taibjk(a,i,b,j,kdiis)
      endpardo a,i,b,j,kdiis
      pardo a,i,b,j,kdiis
          Taibjk(a,i,b,j,kdiis) = 0.0
          prepare Eaibj(a,i,b,j,kdiis) = Taibjk(a,i,b,j,kdiis)
      endpardo a,i,b,j,kdiis
#
      server_barrier
      endproc clear_diis
#     -------------
      PROC MOVET2
#     ------------
#
      PARDO b, a, j, i
#
            REQUEST                    T2old_ab(a,i,b,j) a
            Taibj(a,i,b,j)           = T2old_ab(a,i,b,j)

            if niter < diis_order
               PREPARE Daibj(a,i,b,j,kiter) = Taibj(a,i,b,j)
            endif

            if niter >= diis_order
               kcount = 1.0
               DO kdiis
                  kcount += 1.0
                  if kcount == diis_order
                     PREPARE Daibj(a,i,b,j,kdiis) = Taibj(a,i,b,j)
                     exit
                  endif
               ENDDO kdiis
            endif
      ENDPARDO b, a, j, i
#
      ENDPROC MOVET2
#
#    ------------------------------------------------------------------------ 
#           MAIN
#    ------------------------------------------------------------------------ 
    println "starting CIS-CCPT(2)"
    ecrit = 0.00000001
    zero = 0.0
    one = 1.0
    two = 2.0
    five  = 5.0
    six   = 6.0
    seven = 7.0
#
    diis_start = 2.0
    diis_order = 8
    print_scalar diis_start
    print_scalar diis_order
    server_barrier
#
    restore_persistent ca "ca"
    restore_persistent Fock_a "fock_a"
    restore_persistent     ck0 "Ck0"
    restore_persistent     Ek "CEk"
    restore_persistent M2old_ab "T2old_ab"
    call read_2el
    server_barrier
# second-order starting guess for the T2 amps
#
      kroot = 1.0
      do kstate
          server_barrier
          println " "
          print_scalar kroot
#
          execute return_sval Ek(kstate) shift
          server_barrier
          call iguess_uhf
          server_barrier
          call setroot
          call Caibj
          server_barrier
#
          kroot += 1.0
#
    eold = 0.0
    niter = 0.0
    do kiter
        niter += 1.0
        server_barrier
#
        call t2new_zero
#
        call t2newab
#
        call hhladder_ab # hh
        call phladder_ab # ph
        call AOppladder_ab # pp
        server_barrier
#
        call updatet2
        server_barrier
        call make_hbar
        call cisd_energy
        server_barrier
        call energy
        server_barrier
#
        if niter >= diis_start
            call diisn
        endif
        call movet2
        server_barrier
            ediff = eold - ecorrT
            print_scalar ediff
         IF ecorrT < eold
            ediff = eold - ecorrT
            IF ediff < ecrit
               exit # kiter 
            ENDIF
         ENDIF
#
         IF ecorrT > eold
            ediff = ecorrT - eold
            IF ediff < ecrit
               exit # kiter 
            ENDIF
         ENDIF
#
#        Reset eold --> enew 
#        ------------------- 
#
         eold = ecorrT
#
    enddo kiter
#
    call clear_diis
#
    server_barrier
    totenerg  = ecorrT
    totenerg += scfeneg
    print_scalar totenerg

      enddo kstate
#
      execute print_static_array Ekd
#
      server_barrier
#
      server_barrier
      set_persistent     ca    "ca" 
      set_persistent     Fock_a "fock_a"
      set_persistent     T2old_ab "T2old_ab"
      set_persistent     Viaai  "Viaai"
      set_persistent     Vaaii  "Vaaii"
      set_persistent     Vpiqj  "Vpiqj"
      set_persistent     VSpipi "VSpipi"
      set_persistent     ck0 "Ck0"
      set_persistent     Ek "CEk"
#
#    ------------------------------------------------------------------------ 
                           ENDSIAL CCSD_RHF_SV1
