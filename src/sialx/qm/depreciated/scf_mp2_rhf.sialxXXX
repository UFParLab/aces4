#  Copyright (c) 2003-2010 University of Florida
import "scf_mp2_defs.sialx"
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
#
                           SIAL SCF_MP2_RHF         
#
# ----------------------------------------------------------------------------
#
# The sial program SIAL_UHF performs a UHF based SCF calculation. Davidson 
# damping is performed during the first scf_beg-1 iterations after which the 
# DIIS is turned on with scf_order. At present DIIS is turned on after the 
# third iteration and 6 histories are kept. 
#

# Fock matrix final arrays:
# ------------------------- 
#
# 1. Fpq_a  
# 2. Fpq_b  
#
# Transformation coefficients final arrays:
# ----------------------------------------- 
#
# 1. Ca  
# 2. Cb  
#
# Converged SCF energy:
# --------------------- 
#
# 1. scfeneg 
#
# BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
#
# Declare indices 
# --------------- 
#
#
      index   kiter  = 1: scf_iter  
      #index   kiter  = 1, 1  
      index   kbeg   = 1: scf_beg
      index   korder = 1: scf_hist
      index   kptr1  = 1: 2
      index   kptr2  = 1: 2
      index   kone   = 1: 1
      index   kdiis  = 1: 30 
      index   d1     = 1: 30 
      index   d2     = 1: 30 
      index   d3     = 1: 30 
      index   d4     = 1: 30 
      index   iiter1 = 1: 1
      index   jjter1 = 1: 1
      index   jjter2 = 2: 2
#
      aoindex mu     = 1: norb
      aoindex nu     = 1: norb
      aoindex lambda = 1: norb
      aoindex sigma  = 1: norb
#
      moaindex i = baocc: eaocc
      moaindex i1= baocc: eaocc
      moaindex i2= baocc: eaocc
      moaindex i3= baocc: eaocc
#
      moaindex a = bavirt: eavirt
      moaindex a1= bavirt: eavirt
      moaindex a2= bavirt: eavirt
      moaindex a3= bavirt: eavirt
#
      moaindex j = baocc: eaocc
      moaindex j1= baocc: eaocc
      moaindex j2= baocc: eaocc
      moaindex j3= baocc: eaocc
#
      moaindex b = bavirt: eavirt
      moaindex b1= bavirt: eavirt
      moaindex b2= bavirt: eavirt
      moaindex b3= bavirt: eavirt
#
      moaindex p = baocc: eavirt
      moaindex p1= baocc: eavirt
      moaindex p2= baocc: eavirt
      moaindex p3= baocc: eavirt
#
      moaindex q = baocc: eavirt
      moaindex q1= baocc: eavirt
      moaindex q2= baocc: eavirt
      moaindex q3= baocc: eavirt
# 
# Declare one-particle density arrays 
# ----------------------------------- 
#
      distributed Dhfa[mu,nu] 
      distributed Dhfb[mu,nu] 
      distributed Dhfa_old[mu,nu] 
      distributed Dhfb_old[mu,nu] 
#
      distributed Fpq_a[mu,nu] 
      distributed Fpq_b[mu,nu] 
      distributed FTpq_a[mu,nu] 
      distributed FTpq_b[mu,nu] 
      distributed CBT_a[mu,p] 
      distributed CBT_b[mu,q] 

      static dflags11[iiter1,jjter1]
      static dflags12[iiter1,jjter2]
#
# Declare temporary arrays 
# ------------------------ 
#
      temp txa[mu,a] 
      temp Ixi[mu,i] 
      temp I1xi[mu,i] 
      temp Ixj[mu,j] 
      temp I1xj[mu,j] 
      temp Tpq[mu,nu] 
      temp T1pq[mu,nu] 
      temp Txi[mu,i] 
      temp Tix[i,mu] 
      temp Tax[a,mu] 
      temp T1xi[mu,i] 
      temp Txj[mu,j] 
      temp T1xj[mu,j] 
      temp Txx[mu,nu] 
      temp TAxx[mu,nu] 
      temp TBxx[mu,nu] 
      temp T1xx[mu,nu] 
      temp T2xx[mu,nu] 
      temp T3xx[mu,nu] 
      temp T4xx[mu,nu] 
      temp T5xx[mu,nu] 
      temp T6xx[mu,nu] 
      temp T7xx[mu,nu] 
      temp T8xx[mu,nu] 
      temp T9xx[mu,nu] 
      temp T10xx[mu,nu] 
      temp T11xx[mu,nu] 
      temp T12xx[mu,nu] 
      temp T13xx[mu,nu] 
      temp T14xx[mu,nu] 
      temp T15xx[mu,nu] 
      temp T16xx[mu,nu] 
      temp T17xx[mu,nu] 
      temp T18xx[mu,nu] 
      temp T19xx[mu,nu] 
      temp T20xx[mu,nu] 
      temp T21xx[mu,nu] 
      temp T22xx[mu,nu] 
      temp Tii[i,i1] 
      temp T1ii[i,i1] 
      temp Tjj[j,j1] 
      temp T1jj[j,j1] 
      temp Txp[mu,p] 
      temp T1xp[mu,p] 
      temp Tpp[p,p1] 
      temp T1pp[p,p1] 
      temp Txq[mu,q] 
      temp T1xq[mu,q] 
      temp Tqq[q,q1] 
      temp T1qq[q,q1] 
      temp Tpx[p,mu] 
#
# Declare integral arrays 
# --------------------- 
#
      temp aoint[mu,nu,lambda,sigma]
      distributed Daoint[mu,nu,lambda,sigma]
      temp txaxa[mu,a,lambda,a1] 
#
# Declare static arrays 
# --------------------- 
#
      static FSpq_a[mu,nu] 
      static FSpq_b[mu,nu] 
      distributed Qxx[mu,nu] 
      distributed FTa[p,p1] 
      distributed FTb[q,q1] 
      static X1[mu,nu] 
      local LDHFa[mu,nu] 
      local LDHFb[mu,nu] 
      local LFpq_b[mu,nu] 
      local LFpq_a[mu,nu] 
      static pinf[kiter,kptr1]
      temp tpinf[kiter,kptr1]
#
# Arrays used in DIIS procedure 
# ----------------------------- 
#  
      distributed FFai[a,i] 
      distributed FFbj[b,j] 
      temp tai[a,i] 
      temp t1ai[a,i] 
      temp tbj[b,j] 
      temp t1bj[b,j] 
      scalar dens_check 
      scalar pcount 
#
# Declare scalars 
# --------------- 
#
      scalar e_a     
      scalar e_b     
      scalar escf_a 
      scalar escf_b 
      scalar etemp 
      scalar esum 
      scalar esum1
      scalar energy 
      scalar energy1 
      scalar energy2 
      scalar ecrit 
      scalar ediff  
#     scalar damp 
      scalar damp1 
      scalar done 
      scalar donea 
      scalar doneb 
   
      scalar zero 
      scalar mone 
      scalar one
      scalar two
      scalar three
      scalar four
      scalar ncount1 
      scalar rank 
#
# Parameters needed for DIIS 

      scalar diis_start  
      scalar diis_end   
      scalar diis_order   
      scalar diis_max_order # same as kdiis   
      scalar diis_count 
      scalar worder  
      scalar n1 
      scalar n2 
# scratch memory for integral calculation 
      scalar imax 
      scalar zmax 

      distributed Fa[mu,nu,kdiis] 
      distributed Fb[mu,nu,kdiis] 
      distributed Fbj[b,j,kdiis] 
      distributed Fai[a,i,kdiis] 
      temp tpqx[mu,nu,d2]   
      temp taix[a,i,d2]   
      temp tbjx[b,j,d2]   
      temp tdd[d1,d2] 
      temp t1dd[d1,d2] 
      static BB[d1,d2] 
#
# Arrays used in mp2 calculation
#
      distributed Vxixi[mu,i1,nu,i]
      distributed Vaiai[a,i1,a1,i]
      distributed VSaiai[a,i1,a1,i]
      distributed Vxjxj[mu,j1,nu,j]
      distributed Vbjbj[b,j1,b1,j]
      distributed Vxixj[mu,i,nu,j]
      distributed Vaibj[a,i,b,j]

      temp V0xxxi[mu,nu,lambda,i]
      temp V2xxxi[mu,nu,sigma,i]

      temp Txxxi[mu,nu,lambda,i]
      temp Txxxj[mu,nu,lambda,j]
      temp Txiai[mu,i,a,i1]
      temp T1xiai[mu,i,a,i1]
      temp Txjbj[mu,j,b,j1]
      temp Txibj[mu,i,b,j1]
      temp Txixi[mu,i,nu,i1]
      temp T1xixi[mu,i,nu,i1]
      temp Txjxj[mu,j,nu,j1]
      temp T1xjxj[mu,j,nu,j1]
      temp Txixj[mu,i,nu,j]
      temp T1xixj[mu,i,nu,j]
      temp Taiai[a,i,a1,i1]
      temp T1aiai[a,i,a1,i1]
      temp Tbjbj[b,j,b1,j1]
      temp T1bjbj[b,j,b1,j1]
      temp Taibj[a,i,b,j]
      temp T1aibj[a,i,b,j]

      scalar ecorraa 
      scalar esumaa 
      scalar mp2_energy 
 
# ---------------------------------------------------------------------------- 
#
# -----------------------------------------------------------------------------
#
      PROC HFDENS
#     -----------
#
#     The HF density is computed. Davidson damping is incorporated thus
#     knowledge of the previous iteration is needed. 
#     ----------------------------------------------------------------- 
#
      PARDO mu, nu 
#
#           alpha component first 
#           --------------------- 
#
            GET           DHFa_old[mu,nu] 
            GET           DHFb_old[mu,nu] 
            Tpq[mu,nu]  = DHFa_old[mu,nu]   
            Tpq[mu,nu] *= damp  
#
            DO i 
#
               Txi[nu,i]   = ca[nu,i]
               T1pq[mu,nu] = Txi[nu,i]*ca[mu,i]
               Tpq[mu,nu] += T1pq[mu,nu] 
#
            ENDDO i 
#
            Tpq[mu,nu]     *= damp1   
            PUT Dhfa[mu,nu] = Tpq[mu,nu]
#
#           beta component next  
#           ------------------- 
#
            Tpq[mu,nu]  = DHFb_old[mu,nu]   
            Tpq[mu,nu] *= damp  
#
            DO j 
#
               Txj[nu,j]   = ca[nu,j]
               T1pq[mu,nu] = ca[mu,j]*Txj[nu,j]
               Tpq[mu,nu] += T1pq[mu,nu] 
#
            ENDDO j 
#
            Tpq[mu,nu]     *= damp1   
            PUT Dhfb[mu,nu] = Tpq[mu,nu]
#
      ENDPARDO mu, nu 
#
      ENDPROC HFDENS
#     --------------
#
# ---------------------------------------------------------------------------- 
#
# -----------------------------------------------------------------------------
#
      PROC HFIDENS
#     ------------
#
#     Procedure which computes the HF density without Davidson damping. 
#     ----------------------------------------------------------------- 
#
      PARDO mu, nu 
#
#           alpha component 
#           --------------- 
#
            Tpq[mu,nu] = 0.0 
#
            DO i 
#
               Txi[nu,i]   = ca[nu,i]
               T1pq[mu,nu] = Txi[nu,i]*ca[mu,i]
               Tpq[mu,nu] += T1pq[mu,nu] 
#
              #Tix(i,nu)   = ca(nu,i)
              #T1pq(mu,nu) = ca(mu,i)*Tix(i,nu)
              #Tpq(mu,nu) += T1pq(mu,nu) 
#
            ENDDO i 
# 
            PUT Dhfa[mu,nu] = Tpq[mu,nu]
#
#           beta component 
#           -------------- 
#
            Tpq[mu,nu] = 0.0 
#
            DO j 
#
               Txj[nu,j]   = ca[nu,j]
               T1pq[mu,nu] = ca[mu,j]*Txj[nu,j]
               Tpq[mu,nu] += T1pq[mu,nu] 
#
            ENDDO j 
#
            PUT Dhfb[mu,nu] = Tpq[mu,nu]
#
      ENDPARDO mu, nu 
#
      ENDPROC HFIDENS
#     ---------------
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#

# ---------------------------------------------------------------------------- 
#
       PROC FOCK_MATRIX_FAST   
#      --------------------- 
#
#      The complete Fock matrix is constructed. Eight fold symmetry of the
#      two-electron integrals is incorporated. 
#      ------------------------------------------------------------------
#
#      Put the density into local arrays 
#      --------------------------------- 
#
#      Initialize the Fock matrix to the bare 1-electron hamiltonian.
#      -------------------------------------------------------------- 
#
       sip_barrier
       DO mu
       DO nu
#
          Txx[mu,nu]        = 0.0
          Fockrohf_a[mu,nu] = Txx[mu,nu]
          Fockrohf_b[mu,nu] = Txx[mu,nu]
       ENDDO nu
       ENDDO mu 

       sip_barrier
#
#      Add contributions containing two-particle integral contributions.
#      -----------------------------------------------------------------
#
############# CLASS 6  ############
##  Do four-center part (mu nu |la si)->(mu nu |si la ),(nu mu|la si),(nu mu|si la)
##                      (la si |mu nu),(si la |mu nu),(la si |nu mu),(si la |nu mu)
##
        PARDO mu, nu, lambda, sigma
##
                 WHERE mu      < nu
                 WHERE lambda  < sigma
                 WHERE mu     < lambda
                 WHERE nu     != sigma
                 WHERE nu     != lambda
                 WHERE mu     != sigma
##
                    execute compute_ubatch1 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
##
        ENDPARDO mu, nu, lambda, sigma
##
#
############ CLASS 3  ############
#  Do two-center part (mu mu |mu nu)->(mu nu |mu mu ),(mu mu|nu mu),(nu mu|mu mu)
#  Do three-center part (mu mu |nu lambda)->(mu mu |lambda nu ),(nu lambda|mu mu),(lambda nu|mu mu)
#
       PARDO mu, nu, lambda, sigma 
#
          WHERE mu == nu
          WHERE lambda  < sigma
#
                execute compute_ubatch2 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
#
       ENDPARDO mu, nu, lambda, sigma 
#
############ CLASS 5  ############
###################  CLASS A ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
#
#
       PARDO mu, nu, lambda, sigma
                WHERE nu < sigma
                WHERE mu < nu
                WHERE lambda < sigma
                WHERE mu==lambda
#
                   execute compute_ubatch4 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
#
       ENDPARDO mu, nu, lambda, sigma

###################  CLASS B ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
# 
      PARDO mu, nu, lambda, sigma 
                WHERE mu < nu
                WHERE lambda < sigma
                WHERE mu < sigma
                WHERE nu == lambda
#
                   execute compute_ubatch4 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
#
       ENDPARDO mu, nu, lambda, sigma
#
# 
###################  CLASS C ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
#
       PARDO mu, nu, lambda, sigma
                WHERE mu < nu
                WHERE lambda < sigma
                WHERE mu < lambda
                WHERE nu == sigma
#
                   execute compute_ubatch4 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
#
       ENDPARDO mu, nu, lambda, sigma
#
############ CLASS 4  ############
#  Do two-center part (mu nu |mu nu)->(mu nu |nu mu ),(nu mu|mu nu),(nu mu|nu mu)
#
       PARDO mu, nu, lambda, sigma
                WHERE mu < nu
                WHERE lambda < sigma 
                WHERE nu == sigma
                WHERE mu == lambda
#
                   execute compute_ubatch8 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
#
       ENDPARDO mu, nu, lambda, sigma
#          
############ CLASS 2  ############
#  Do two-center part (mu mu |nu nu)->(nu nu |mu mu )
#
       PARDO mu, nu, lambda, sigma
#
             WHERE mu < lambda
             WHERE mu == nu
             WHERE lambda == sigma
#
                   execute compute_ubatch7 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
#
       ENDPARDO mu, nu, lambda, sigma 
#
############ END CLASS 2  ############
#
#
############ CLASS 1  ############
#  Do one-center part (mu mu |mu mu)
#
       PARDO mu, nu, lambda, sigma
             WHERE nu == mu
             WHERE sigma == mu
             WHERE lambda == mu 
#
                   execute compute_ubatch6 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
#
       ENDPARDO mu, nu, lambda, sigma
#
############ END CLASS 1  ############
#
       sip_barrier
#      
       DO mu
       DO nu
#         
          Txx[mu,nu]        = Fockrohf_a[mu,nu]
          PUT Fpq_a[mu,nu] += Txx[mu,nu]
#      
       ENDDO nu
       ENDDO mu 
#      
       DO mu
       DO nu
#         
          Txx[mu,nu]        = Fockrohf_b[mu,nu]
          PUT Fpq_b[mu,nu] += Txx[mu,nu]
#      
       ENDDO nu
       ENDDO mu 
#
       sip_barrier
#
       execute get_my_rank rank  
       if rank == 0.0 
       DO mu    
       DO nu   
#
            execute return_h1 txx[mu,nu] 
#
            PUT Fpq_a[mu,nu] += Txx[mu,nu] 
            PUT Fpq_b[mu,nu] += Txx[mu,nu] 
#
       ENDDO nu   
       ENDDO mu    
       endif 
#
       ENDPROC FOCK_MATRIX_FAST   
#      ------------------------ 
#
# ---------------------------------------------------------------------------- 
#
#
       PROC HF_ENERGY  
#      -------------- 
#
#      The HF energy is computed from the HF density (DHFa(b)) and the 
#      Fock matrix (Fpq_a(b)). 
#      --------------------------------------------------------------- 
#
       energy = 0.0
       esum = 0.0 

       execute get_my_rank rank 
       if rank == 0.0 

          DO mu  
          DO nu 
#
             GET Fpq_a[mu,nu]
             GET Fpq_b[mu,nu]
             GET DHFa[mu,nu] 
             GET DHFb[mu,nu] 
#
             Txx[mu,nu]   = 0.0 
             execute return_h1 txx[mu,nu]  
#
             T1xx[mu,nu]  = Txx[mu,nu] 
             T1xx[mu,nu] += Fpq_a[mu,nu] 
#
             etemp        = T1xx[mu,nu]*DHFa[mu,nu]  
             esum        += etemp 
#
             T1xx[mu,nu]  = Txx[mu,nu] 
             T1xx[mu,nu] += Fpq_b[mu,nu] 
#
             etemp        = T1xx[mu,nu]*DHFb[mu,nu]  
             esum        += etemp 
#
          ENDDO nu 
          ENDDO mu 

       endif 


       sip_barrier 

       esum *= 0.5 
       collective energy += esum 
       energy += scfeneg 
#
       #print_scalar esum  
        print energy 
#
       ENDPROC HF_ENERGY   
#      ----------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC OVER_HALF 
#      -------------- 
#
#      Diagonalize the overlap matrix, invert and take the square
#      root of the diagonal elements. 
#      -------------------------------------------------------------- 
#
       DO mu 
       DO nu 
          execute return_ovl txx[mu,nu] 
          oed_ovl[mu,nu] = txx[mu,nu]  
       ENDDO nu 
       ENDDO mu 
       sip_barrier 
       execute eig_sr_inv oed_ovl x1   
#
#      Form the Q-matrix --> U s**{-1/2) 
#      --------------------------------- 
#
       PARDO mu, nu  
#
          Txx[mu,nu] = 0.0 
#
          DO lambda 
             T1xx[mu,nu] = x1[mu,lambda]*oed_ovl[lambda,nu] 
             Txx[mu,nu] += T1xx[mu,nu] 
          ENDDO lambda  
#
          PUT Qxx[mu,nu] = Txx[mu,nu]  
#
       ENDPARDO mu, nu  
#
      #execute print_scalar scfeneg
       ENDPROC OVER_HALF 
#      ----------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC FOCK_TRANSPOSE 
#      ------------------- 
#
#      Form the transposed Fock matrix --> Q+ F Q 
#      ------------------------------------------ 
#
       PARDO mu, sigma   
#
             TAxx[mu,sigma] = 0.0 
             TBxx[mu,sigma] = 0.0 
#
             DO lambda 
#
                GET Fpq_a[lambda,sigma] 
                GET Fpq_b[lambda,sigma] 
                GET Qxx[lambda,mu] 

                t3xx[mu,lambda] = Qxx[lambda,mu] 
#
               #T1xx(mu,sigma)  = Qxx(lambda,mu)*Fpq_a(lambda,sigma)  
                T1xx[mu,sigma]  = t3xx[mu,lambda]*Fpq_a[lambda,sigma]  
                TAxx[mu,sigma] += T1xx[mu,sigma] 
#
               #T1xx(mu,sigma)  = Qxx(lambda,mu)*Fpq_b(lambda,sigma)  
                T1xx[mu,sigma]  = t3xx[mu,lambda]*Fpq_b[lambda,sigma]  
                TBxx[mu,sigma] += T1xx[mu,sigma] 
#
             ENDDO lambda 
#
             DO nu 
#
                GET Qxx[sigma,nu] 
#
                T1xx[mu,nu] =        TAxx[mu,sigma]*Qxx[sigma,nu] 
                PUT FTpq_a[mu,nu] += T1xx[mu,nu] 
#
                T2xx[mu,nu]        = TBxx[mu,sigma]*Qxx[sigma,nu] 
                PUT FTpq_b[mu,nu] += T2xx[mu,nu] 
#
             ENDDO nu 
#
       ENDPARDO mu, sigma   
#
       ENDPROC FOCK_TRANSPOSE 
#      ---------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC FOCK_DIAG  
#      -------------- 
#
#      First put the transposed Fock arrays into static arrays 
#      ------------------------------------------------------- 
#
       DO mu   
       DO nu  
#
          GET             FTpq_a[mu,nu] 
          GET             FTpq_b[mu,nu]
#
          FSpq_a[mu,nu] = FTpq_a[mu,nu]
          FSpq_b[mu,nu] = FTpq_b[mu,nu]
#
       ENDDO nu  
       ENDDO mu   
#
       execute eigen_calc FSpq_a ca
      #execute eigen_calc FSpq_b Cb  
#
       ENDPROC FOCK_DIAG 
#      ----------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC C_BTRAN 
#      ------------ 
#
#      Transform the coefficient array back to the original basis 
#      ---------------------------------------------------------- 
#
       PARDO mu, p  
#
          Txp[mu,p] = 0.0 
#
          DO nu 
#
             GET          Qxx[mu,nu] 
#
             T1xp[mu,p] = Qxx[mu,nu]*ca[nu,p]   
             Txp[mu,p] += T1xp[mu,p] 
#
          ENDDO nu 
#
          PUT CBT_a[mu,p] = Txp[mu,p] 
#
       ENDPARDO mu, p  
#
       PARDO mu, q
# 
          Txq[mu,q] = 0.0 
#
          DO nu 
#
             GET          Qxx[mu,nu] 
#
             T1xq[mu,q] = Qxx[mu,nu]*ca[nu,q]   
             Txq[mu,q] += T1xq[mu,q] 
#
          ENDDO nu 
#
          PUT CBT_b[mu,q] = Txq[mu,q] 
#
       ENDPARDO mu, q
       sip_barrier 
#
#      Put the transformed coefficients into static arrays 
#      --------------------------------------------------- 
#
       DO mu 
       DO p 
          GET        CBT_a[mu,p] 
          ca[mu,p] = CBT_a[mu,p] 
       ENDDO p 
       ENDDO mu  
#
       ENDPROC C_BTRAN 
#      --------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC HFDENS_ZERO   
#      ----------------  
#  
#      Zero out the n-1'th density array. 
#      ---------------------------------- 
#
       PARDO mu, nu 
#
             Txx[mu,nu]   = 0.0   
             PUT DHFa_old[mu,nu] = Txx[mu,nu]  
             PUT DHFb_old[mu,nu] = Txx[mu,nu]  
#
       ENDPARDO mu, nu 
#
       ENDPROC HFDENS_ZERO   
#      ------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC HFDENS_REPLACE    
#      -------------------   
#
#      Replace the 'old' HF density by the 'new' HF density. 
#      ----------------------------------------------------- 
#
       PARDO mu, nu 
#
             GET DHFa[mu,nu] 
             GET DHFb[mu,nu] 
             PUT DHFa_old[mu,nu] = DHFa[mu,nu]  
             PUT DHFb_old[mu,nu] = DHFb[mu,nu]  
#
       ENDPARDO mu, nu 
#
       ENDPROC HFDENS_REPLACE    
#      ----------------------  
#
# ---------------------------------------------------------------------------- 
#
       PROC GEN_6HISTORY  
#      ------------------  
#
       DELETE FFai
       DELETE FFbj
       CREATE FFai
       CREATE FFbj
       sip_barrier 
#  
       PARDO mu, nu  
             GET Fpq_a[mu,nu]  
             GET Fpq_b[mu,nu]  
             DO i 
                txi[mu,i] = Fpq_a[mu,nu]*ca[nu,i] 
                DO a 
                   tai[a,i]      = txi[mu,i]*ca[mu,a] 
                   PUT FFai[a,i] += tai[a,i] 
                ENDDO a 
             ENDDO i 
#
             DO j 
                txj[mu,j] = Fpq_b[mu,nu]*ca[nu,j] 
                DO b 
                   tbj[b,j]      = txj[mu,j]*ca[mu,b] 
                   PUT FFbj[b,j] += tbj[b,j] 
                ENDDO b 
             ENDDO j 
       ENDPARDO mu, nu  
       sip_barrier 
#
       n1 = diis_start  
       n1-= 1.0  
       DO d1 
          n1 += 1.0 
          if n1 == worder  
#
                PARDO mu, nu 
                   GET              Fpq_a[mu,nu] 
                   GET              Fpq_b[mu,nu] 
                   txx[mu,nu]     = Fpq_a[mu,nu] 
                   PUT Fa[mu,nu,d1] = txx[mu,nu]  
                   txx[mu,nu]     = Fpq_b[mu,nu] 
                   PUT Fb[mu,nu,d1] = txx[mu,nu]  
                ENDPARDO mu, nu 
                PARDO a, i 
                   GET FFai[a,i] 
                   PUT Fai[a,i,d1] = FFai[a,i]  
                ENDPARDO a, i 
                PARDO b, j 
                   GET FFbj[b,j] 
                   PUT Fbj[b,j,d1] = FFbj[b,j]  
                ENDPARDO b, j 
                exit 

          endif # d1 = kiter 
#
       ENDDO d1 
#
       sip_barrier 
#
       ENDPROC GEN_6HISTORY  
#      ---------------------  
#
# ---------------------------------------------------------------------------- 
#
       PROC MOVE6    
#      ----------  
#
#      Move histories 
#      -------------- 
#
       PARDO mu, nu 
          n1 = 0.0 
          DO d1 
             n1 += 1.0 
             GET          Fa[mu,nu,d1] 
             tpq[mu,nu] = Fa[mu,nu,d1] 
             n2 = 0.0 
          DO d2 
             n2 += 1.0 
             etemp = n1 
             etemp-= n2 
             if etemp == 1.0 
                tpqx[mu,nu,d2]   = tpq[mu,nu] 
                PUT Fa[mu,nu,d2] = tpqx[mu,nu,d2] 
               #PUT Fa(mu,nu,d2) = tpq(mu,nu) 
             endif 
          ENDDO d2 
          ENDDO d1 
       ENDPARDO mu, nu 
#
       PARDO a, i 
          n1 = 0.0 
          DO d1 
             n1 += 1.0 
             GET        Fai[a,i,d1] 
             tai[a,i] = Fai[a,i,d1] 
             n2 = 0.0 
          DO d2 
             n2 += 1.0 
             etemp = n1 
             etemp-= n2 
             if etemp == 1.0 
                taix[a,i,d2]   = tai[a,i] 
                PUT Fai[a,i,d2] = taix[a,i,d2] 
               #PUT Fai(a,i,d2) = tai(a,i) 
             endif 
          ENDDO d2 
          ENDDO d1 
       ENDPARDO a,i  
#
       PARDO mu, nu 
          n1 = 0.0 
          DO d1 
             n1 += 1.0 
             GET          Fb[mu,nu,d1] 
             tpq[mu,nu] = Fb[mu,nu,d1] 
             n2 = 0.0 
          DO d2 
             n2 += 1.0 
             etemp = n1 
             etemp-= n2 
             if etemp == 1.0 
                tpqx[mu,nu,d2]   = tpq[mu,nu] 
                PUT Fb[mu,nu,d2] = tpqx[mu,nu,d2] 
               #PUT Fb(mu,nu,d2) = tpq(mu,nu) 
             endif 
          ENDDO d2 
          ENDDO d1 
       ENDPARDO mu, nu 
#
       PARDO b, j 
          n1 = 0.0 
          DO d1 
             n1 += 1.0 
             GET        Fbj[b,j,d1] 
             tbj[b,j] = Fbj[b,j,d1] 
             n2 = 0.0 
          DO d2 
             n2 += 1.0 
             etemp = n1 
             etemp-= n2 
             if etemp == 1.0 
                tbjx[b,j,d2]   = tbj[b,j] 
                PUT Fbj[b,j,d2] = tbjx[b,j,d2] 
               #PUT Fbj(b,j,d2) = tbj(b,j) 
             endif 
          ENDDO d2 
          ENDDO d1 
       ENDPARDO b,j  
                
       sip_barrier 
#
       ENDPROC MOVE6    
#      -------------  
#
# ---------------------------------------------------------------------------- 
#
       PROC DIISN   
#      ----------  
#
# The DIIS expansion coefficients are computed using the 5 previous iterations.
#
#      Zero out scalars.
#      -----------------
#
      #CALL ZERO_SCALAR 
#
       sip_barrier 
#
#      Determine the 'B-matrix'. 
#      ------------------------- 
#
#      Contributions from Fai histories. 
#      --------------------------------- 
#
       n1 = 0.0 
       DO d1 
          n1+= 1.0 
       if n1 <= worder 
          n2 = 0.0 
       DO d2 
          n2+= 1.0 
       if n2 <= worder 
          tdd[d1,d2] = 0.0 
          DO a  
          DO i 
             GET           Fai[a,i,d1] 
             GET           Fai[a,i,d2] 
             tai[a,i]    = Fai[a,i,d1] 
             t1ai[a,i]   = Fai[a,i,d2] 
             etemp       = tai[a,i]*t1ai[a,i] 
             t1dd[d1,d2] = etemp 
             tdd[d1,d2] += t1dd[d1,d2]  
          ENDDO i 
          ENDDO a  
          DO b  
          DO j 
             GET           Fbj[b,j,d1] 
             GET           Fbj[b,j,d2] 
             tbj[b,j]    = Fbj[b,j,d1] 
             t1bj[b,j]   = Fbj[b,j,d2] 
             etemp       = tbj[b,j]*t1bj[b,j] 
             t1dd[d1,d2] = etemp 
             tdd[d1,d2] += t1dd[d1,d2]  
          ENDDO j 
          ENDDO b  
          BB[d1,d2] = tdd[d1,d2] 

       endif 
       ENDDO d2 
       endif 
       ENDDO d1 
#
       execute compute_diis BB 
#
#      Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#      --------------------------------------------------------------------------------------
#
       sip_barrier
#
#      Done computing the c-vector.
#      ----------------------------
#
#      Form the update Density matrix using the c-vector. 
#      -----------------------------------------------
#
       PARDO mu, nu 
#
           txx[mu,nu] = 0.0 
#
           n1 = 0.0 
           DO d1   
              n1 += 1.0 
           if n1 <= worder 
              GET            Fa[mu,nu,d1] 
              t1xx[mu,nu]  = Fa[mu,nu,d1] 
              execute return_sval BB[d1,d1] etemp 
             #etemp        = BB(d1,d1)        
              t1xx[mu,nu] *= etemp   
              txx[mu,nu]  += t1xx[mu,nu] 
           endif 
           ENDDO d1   
#
           PUT Fpq_a[mu,nu] = txx[mu,nu] 
#
           txx[mu,nu] = 0.0 
#
           n1 = 0.0 
           DO d1   
              n1 += 1.0 
           if n1 <= worder 
              GET            Fb[mu,nu,d1] 
              t1xx[mu,nu]  = Fb[mu,nu,d1] 
              execute return_sval BB[d1,d1] etemp 
             #etemp        = BB(d1,d1)        
              t1xx[mu,nu] *= etemp   
              txx[mu,nu]  += t1xx[mu,nu] 
           endif 
           ENDDO d1   
#
           PUT Fpq_b[mu,nu] = txx[mu,nu] 
#
       ENDPARDO mu, nu 
#
       sip_barrier 
#
       ENDPROC DIISN   
#      -------------  
#
# ---------------------------------------------------------------------------- 
#
      PROC IGUESS
         execute get_my_rank rank 
       if rank == 0.0 
         DO mu  
         DO nu 
            Txx[mu,nu]      = 0.0
            execute return_h1 Txx[mu,nu]
            PUT Fpq_a[mu,nu] = Txx[mu,nu]
            PUT Fpq_b[mu,nu] = Txx[mu,nu]
         ENDDO nu 
         ENDDO mu  
       endif 
      ENDPROC IGUESS

#    ------------------------------------------------------------------------ 
#
     PROC TRAN_XXOO 
#
#    ------------------------------------------------------------------------ 
#
# Compute the integrals  
#
     create Daoint 
     esumaa = 0.0 
     sip_barrier 
 
     PARDO mu, nu, lambda, sigma  
           WHERE mu     < nu
           WHERE lambda < sigma
                 execute compute_ubatch6 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
                 PUT Daoint[mu,nu,lambda,sigma] = aoint[mu,nu,lambda,sigma] 
     ENDPARDO mu, nu, lambda, sigma  
 
     PARDO mu, nu, lambda, sigma  
           WHERE mu     == nu
           WHERE lambda < sigma
                 execute compute_ubatch6 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
                 PUT Daoint[mu,nu,lambda,sigma] = aoint[mu,nu,lambda,sigma] 
     ENDPARDO mu, nu, lambda, sigma  
 
     PARDO mu, nu, lambda, sigma  
           WHERE mu     < nu
           WHERE lambda == sigma
                 execute compute_ubatch6 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
                 PUT Daoint[mu,nu,lambda,sigma] = aoint[mu,nu,lambda,sigma] 
     ENDPARDO mu, nu, lambda, sigma  
 
     PARDO mu, nu, lambda, sigma  
           WHERE mu     == nu
           WHERE lambda == sigma
                 execute compute_ubatch6 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
                 PUT Daoint[mu,nu,lambda,sigma] = aoint[mu,nu,lambda,sigma] 
     ENDPARDO mu, nu, lambda, sigma  
 
     sip_barrier 
 
########################################################################
#                                                                      #     
#                                 GPU                                  #
#                                                                      #
########################################################################
    gpu_on
 
        create Vxixi #(*,*,*,i)
        create Vaiai #(*,*,*,i)    
        sip_barrier 
 
        PARDO mu, nu, lambda, sigma  
 
              WHERE mu     < nu
              WHERE lambda < sigma
 
                 GET                      Daoint[mu,nu,lambda,sigma] 

              DO i 
                 V0xxxi[mu,nu,lambda,i] = DAOINT[mu,nu,lambda,sigma]*ca[sigma,i]
                 V2xxxi[mu,nu,sigma,i]  = DAOINT[mu,nu,lambda,sigma]*ca[lambda,i]
 
                 DO i1  
 
                    Txixi[mu,i1,lambda,i]      = V0xxxi[mu,nu,lambda,i]*ca[nu,i1]
                    put Vxixi[mu,i1,lambda,i] += Txixi[mu,i1,lambda,i]
 
                    T1xixi[mu,i1,sigma,i]      = V2xxxi[mu,nu,sigma,i]*ca[nu,i1]
                    put Vxixi[mu,i1,sigma,i]  += T1xixi[mu,i1,sigma,i]
 
                 ENDDO i1  
 
                 DO i1
 
                    Txixi[nu,i1,lambda,i]      = V0xxxi[mu,nu,lambda,i]*ca[mu,i1]
                    put Vxixi[nu,i1,lambda,i] += Txixi[nu,i1,lambda,i]
 
                    T1xixi[nu,i1,sigma,i]      = V2xxxi[mu,nu,sigma,i]*ca[mu,i1]
                    put Vxixi[nu,i1,sigma,i]  += T1xixi[nu,i1,sigma,i]
 
                 ENDDO i1

              ENDDO i 
 
        ENDPARDO mu, nu, lambda, sigma  
 
        PARDO mu, nu, lambda, sigma  
 
              WHERE mu     == nu
              WHERE lambda < sigma
 
                 GET                      Daoint[mu,nu,lambda,sigma] 

              DO i 
                 V0xxxi[mu,nu,lambda,i] = DAOINT[mu,nu,lambda,sigma]*ca[sigma,i]
                 V2xxxi[mu,nu,sigma,i]  = DAOINT[mu,nu,lambda,sigma]*ca[lambda,i]
 
                 DO i1
 
                    Txixi[mu,i1,lambda,i]      = V0xxxi[mu,nu,lambda,i]*ca[nu,i1]
                    put Vxixi[mu,i1,lambda,i] += Txixi[mu,i1,lambda,i]
 
                    T1xixi[mu,i1,sigma,i]      = V2xxxi[mu,nu,sigma,i]*ca[nu,i1]
                    put Vxixi[mu,i1,sigma,i]  += T1xixi[mu,i1,sigma,i]
 
                 ENDDO i1

              ENDDO i 
 
        ENDPARDO mu, nu, lambda, sigma
 
        PARDO mu, nu, lambda, sigma
 
              WHERE mu     < nu
              WHERE lambda == sigma
 
                 GET                      Daoint[mu,nu,lambda,sigma] 

              DO i 
                 V0xxxi[mu,nu,lambda,i] = DAOINT[mu,nu,lambda,sigma]*ca[sigma,i]
 
                 DO i1
 
                    Txixi[mu,i1,lambda,i]      = V0xxxi[mu,nu,lambda,i]*ca[nu,i1]
                    put Vxixi[mu,i1,lambda,i] += Txixi[mu,i1,lambda,i]
 
                    T1xixi[nu,i1,lambda,i]     = V0xxxi[mu,nu,lambda,i]*ca[mu,i1]
                    put Vxixi[nu,i1,lambda,i] += T1xixi[nu,i1,lambda,i]
 
                 ENDDO i1

              ENDDO i 
 
        ENDPARDO mu, nu, lambda, sigma
#
        PARDO mu, nu, lambda, sigma
 
              WHERE mu     == nu
              WHERE lambda == sigma
 
                 GET                      Daoint[mu,nu,lambda,sigma] 

              DO i 
                 V0xxxi[mu,nu,lambda,i] = DAOINT[mu,nu,lambda,sigma]*ca[sigma,i]
 
                 DO i1
 
                    Txixi[mu,i1,lambda,i]      = 0.0  
                    Txixi[mu,i1,lambda,i]      = V0xxxi[mu,nu,lambda,i]*ca[nu,i1]
                    PUT Vxixi[mu,i1,lambda,i] += Txixi[mu,i1,lambda,i]
 
                 ENDDO i1

              ENDDO i 
 
        ENDPARDO mu, nu, lambda, sigma
        
        sip_barrier
 
        PARDO a1, mu, i1

           DO i 
 
           Txiai[mu,i1,a1,i] = 0.0
 
           DO lambda
 
              get                  Vxixi[mu,i1,lambda,i]
              T1xiai[mu,i1,a1,i] = 0.0  
              T1xiai[mu,i1,a1,i] = Vxixi[mu,i1,lambda,i]*ca[lambda,a1]
             #T1xiai(mu,i1,a1,i) = ca(lambda,a1)*Vxixi(mu,i1,lambda,i)
              Txiai[mu,i1,a1,i] += T1xiai[mu,i1,a1,i]
 
           ENDDO lambda
 
           DO a
 
              Taiai[a,i1,a1,i]      = 0.0  
              Taiai[a,i1,a1,i]      = Txiai[mu,i1,a1,i]*ca[mu,a]
             #Taiai(a,i1,a1,i)      = ca(mu,a)*Txiai(mu,i1,a1,i)
              PUT Vaiai[a,i1,a1,i] += Taiai[a,i1,a1,i]
 
           ENDDO a
 
           ENDDO i 
 
        ENDPARDO a1, mu, i1
 
        sip_barrier
        delete Vxixi #(*,*,*,i)
 
        PARDO a, a1, i1

           DO i 
 
              get                        Vaiai[a,i1,a1,i]
              get                        Vaiai[a1,i1,a,i]

              Taiai[a,i1,a1,i]         = Vaiai[a,i1,a1,i]
              T1aiai[a,i1,a1,i]        = Vaiai[a1,i1,a,i]

              Taiai[a,i1,a1,i]        *= 2.0  
              Taiai[a,i1,a1,i]        -= T1aiai[a,i1,a1,i] 
#
# Compute the denominator 
              execute energy_denominator_rhf Taiai[a,i1,a1,i] fock_a 
              etemp                    = Taiai[a,i1,a1,i]*Vaiai[a,i1,a1,i]
              esumaa                  += etemp

           ENDDO i 
 
        ENDPARDO a, a1, i1
 
        sip_barrier
        delete Vaiai #(*,*,*,i)
 
########################################################################
#                                                                      #     
#                                 GPU                                  #
#                                                                      #
########################################################################
    gpu_off
#
#    ------------------------------------------------------------------------ 
#
     ENDPROC TRAN_XXOO
# 
#    ------------------------------------------------------------------------ 

     PROC MP2_RHF
# 
     sip_barrier
     collective ecorraa += esumaa
     sip_barrier

     print ecorraa 
#
     mp2_energy  = ecorraa
     totenerg   = mp2_energy + scfeneg
     print mp2_energy  

# 
#    ------------------------------------------------------------------------ 
# 
     ENDPROC MP2_RHF
# 
#    ------------------------------------------------------------------------ 
# 
############################################################################## 
#
#                         START OF MAIN PROGRAM 
#
############################################################################## 
#
#     Define a few constants 
#     ---------------------- 
#
      ecrit  = scf_conv # Energy tolerance  
     #damp   = 0.0 
      etemp  = 1.0 
      etemp += damp  
      damp1  = 1.0/etemp         # 1/(1+damp)  
      pcount = 0.0 
       print damp 
       print damp1
#
#     New HF density 
#     -------------- 
#
      CREATE DHFa   
      CREATE DHFb   

#     Get memory requirements from integral calculation 
#     ------------------------------------------------- 
      imax = 0.0 
      zmax = 0.0 
      DO mu 
      DO nu 
         txx[mu,nu] = 0.0 
         execute compute_int_scratchmem txx[mu,nu] zmax imax 
      ENDDO nu 
      ENDDO mu 
#
#     Perform initial (aa|bb) integral computation to set Schwartz paramaters 
#     ----------------------------------------------------------------------- 
#
     #DO mu
     #DO nu
     #DO lambda
     #DO sigma
     #      IF mu == lambda
     #      IF nu == sigma
     #         execute compute_aabb_batch aoint(mu,nu,lambda,sigma)
     #      ENDIF
     #      ENDIF
     #ENDDO sigma
     #ENDDO lambda
     #ENDDO nu
     #ENDDO mu

      zero = 0.0 
      mone = -1.0 
      one = 1.0 
      two = 2.0 
      three = 3.0 
      four = 4.0 
      diis_count = 0.0  
      diis_start = 2.0 
      diis_end = 5000.0 
      diis_order = 8.0 
      diis_max_order = 10.0 

      diis_start = 0.0
      do kbeg
         diis_start += 1.0
      ENDDO kbeg

      diis_order = 0.0
      do korder
         diis_order += 1.0
      ENDDO korder

      #print_scalar diis_start
      #print_scalar diis_order

#
#     Create the one-particle arrays needed for the computation. 
#     ---------------------------------------------------------- 
#
#     Fock matrix
#     ----------- 
      CREATE Fpq_a  
      CREATE Fpq_b  
#
#     Old HF density 
#     -------------- 
#
      CREATE DHFa_old    
      CREATE DHFb_old    
#
#     DIIS vectors 
#     ------------ 
#
      create Fa 
      create Fb 
      create Fai  
      create Fbj  
      CREATE FFai
      CREATE FFbj
#
#     Orthonormalizing transformation coefficient
#     ------------------------------------------- 
#
      CREATE Qxx 
      sip_barrier 
#
#     Construct the initial guess of the Fock matrix.
#     -----------------------------------------------
#    
      esum = 0.0
      esum1= 0.0
      sip_barrier

     #if dens_check == -1.0 
      CALL IGUESS 
     #endif 
      #print_scalar dens_check 

#     Construct the array S**(-1/2) 
#     ----------------------------- 
#
      CALL OVER_HALF 
      sip_barrier 

      DO mu
      DO nu
         GET              DHFa[mu,nu]
         GET              DHFb[mu,nu]
         oed_ovl[mu,nu] = DHFa[mu,nu] # 13
         oed_kin[mu,nu] = DHFb[mu,nu] # 12
      ENDDO nu
      ENDDO mu

     #CALL FOCK_MATRIX_FAST 
#
#     Construct S^(-1/2) F S^(-1/2) 
#     ----------------------------- 
#
      CREATE FTpq_a  
      CREATE FTpq_b  
      sip_barrier 
      CALL FOCK_TRANSPOSE 
      sip_barrier 
#
#     -------------------------------------- 
#
      CALL FOCK_DIAG 
#
#     Back transform the coefficient array 
#     ------------------------------------ 
#
      CREATE CBT_a 
      CREATE CBT_b 
      sip_barrier
      CALL   C_BTRAN 
      sip_barrier
#
#     Zero out the 'old' HF density 
#     ----------------------------- 
#
      CALL HFDENS_ZERO 
      sip_barrier
#
#     Compute the HF density 
#     ---------------------- 
#
      CALL HFIDENS

      DO mu 
      DO nu 
         txx[mu,nu] = 0.0 
         Fockrohf_a[mu,nu] = txx[mu,nu]  
         Fockrohf_b[mu,nu] = txx[mu,nu]  
         txx[mu,nu] = oed_ovl[mu,nu]  
      ENDDO nu 
      ENDDO mu 

      dens_check = -1.0 
#      execute scf_atom dens_check   # VFL Commented out

      if dens_check == 1.0 

         DO mu 
         DO nu 
            txx[mu,nu]      = Fockrohf_a[mu,nu]  
            PUT Dhfa[mu,nu] = txx[mu,nu]
            txx[mu,nu]      = Fockrohf_b[mu,nu]  
            PUT Dhfb[mu,nu] = txx[mu,nu]
         ENDDO nu 
         ENDDO mu 

      endif 
      
      sip_barrier
#
#     Damp the HF density 
#     ------------------- 
#
#     CALL HF_DAMP 
#     execute sip_barrier
#
#     Compute the energy 
#     ------------------ 
#
      CALL HF_ENERGY 
      energy1 = energy 
      sip_barrier
#
#     Replace 'old' HF density by 'new' HF density 
#     -------------------------------------------- 
#
      CALL HFDENS_REPLACE 
#
#     Create history arrays 
#     --------------------- 
#
      sip_barrier
#
      DELETE FTpq_a  
      DELETE FTpq_b  
      DELETE Fpq_a  
      DELETE Fpq_b  
      DELETE CBT_a 
      DELETE CBT_b 
#
# Start iterations 
# ---------------- 
#
      DO kiter 
         diis_count += 1.0 
#
#        Create 1-particle arrays 
#        ------------------------ 
#
         CREATE Fpq_a 
         CREATE Fpq_b 
         CREATE CBT_a 
         CREATE CBT_b 
         CREATE FTpq_a  
         CREATE FTpq_b  
         sip_barrier
#
#        Construct the new Fock matrix 
#        -----------------------------

         DO mu
         DO nu
            GET              DHFa[mu,nu]
            GET              DHFb[mu,nu]
            oed_ovl[mu,nu] = DHFa[mu,nu] # 13
            oed_kin[mu,nu] = DHFb[mu,nu] # 12
         ENDDO nu
         ENDDO mu

         CALL FOCK_MATRIX_FAST 
        #CALL FOCK_MATRIX 
         sip_barrier 
#
         CALL HF_ENERGY 
         energy2 = energy 
         sip_barrier
#
#        DONE Compute the DIIS  
#        --------------------- 

         if diis_count < diis_end 

         etemp = diis_start 
         etemp-= 1.0  
         etemp+= diis_order   

        #print_scalar diis_start   
        #print_scalar diis_order    
        #print_scalar etemp  

         worder = 0.0  
         n2 = diis_start 
         n2-= 1.0  
         if diis_count >= n2 
         if diis_count <= etemp 
            worder = diis_count  
            worder+= 1.0    
         endif  
         endif  
        #print_scalar worder   

         if diis_count > etemp 
            worder = etemp  
         endif  
        # print_scalar worder  
#
         if worder > 0.0  
            CALL GEN_6HISTORY 
         endif 
         sip_barrier 
#

         if diis_count >= diis_start
             damp   = 0.0
             etemp  = 1.0
             etemp += damp
             damp1  = 1.0/etemp         # 1/(1+damp)  
         if diis_count <= diis_end
            worder -= diis_start
            worder += 1.0
            #print_scalar worder
            damp  = 0.0
            damp1 = 1.0
            CALL DIISN
            etemp = diis_start
            etemp-= 1.0
            etemp+= diis_order
           #print_scalar etemp 
            if diis_count >= etemp
           #    print_scalar etemp
               CALL MOVE6
           #    print_scalar etemp
            endif
         endif
         endif

         endif # diis_end 

#
#        Transpose the new Fock matrix 
#        -----------------------------
#
         CALL FOCK_TRANSPOSE 
         sip_barrier
#
#        Diagonalize the transposed Fock matrix 
#        -------------------------------------- 
#
         CALL FOCK_DIAG 
         sip_barrier
#
#        Back transform the coefficient array 
#        ------------------------------------ 
#
         CALL C_BTRAN 
#
         done = 0.0 
         sip_barrier
#
#        Check on convergence --> largest HF density difference. 
#        ------------------------------------------------------- 
#
         DO mu 
         DO nu 
#
#           Alpha component 
#           --------------- 
#
            GET           DHFa_old[mu,nu] 
            GET           DHFa[mu,nu] 
#
            T1xx[mu,nu]  = DHFa[mu,nu] 
            T1xx[mu,nu] -= DHFa_old[mu,nu] 
            execute check_dconf T1xx[mu,nu] donea  
            if donea > done 
               done = donea 
            endif 
#
#           Beta component 
#           -------------- 
#
            GET           DHFb_old[mu,nu] 
            GET           DHFb[mu,nu] 
#
            Txx[mu,nu]  = DHFb[mu,nu] 
            Txx[mu,nu] -= DHFb_old[mu,nu] 
            execute check_dconf Txx[mu,nu] doneb  
            if doneb > done 
               done = doneb 
            endif 
#
         ENDDO nu 
         ENDDO mu 
        #print_scalar done 
#
#        Check on convergence using density difference. 
#        ---------------------------------------------- 
#
         IF 1 < kiter # > 1
        #   print_scalar diis_count 
            IF done < ecrit
        #   print_scalar diis_count 
               DELETE FTpq_a
               DELETE FTpq_b
               DELETE CBT_a
               DELETE CBT_b
               exit
            ENDIF
         ENDIF
#
#        Replace 'old' HF density by 'new' HF density 
#        -------------------------------------------- 
#
         CALL HFDENS_REPLACE 
         sip_barrier
#
#        Reset eold --> enew
#        -------------------
#
         energy1 = energy2  
#
#        Compute the HF density 
#        ---------------------- 
#
         CALL HFDENS
         sip_barrier
#
#        Delete one-particle arrays to be used in the next iteration. 
#        ------------------------------------------------------------ 
#
         if kiter < scf_iter
            DELETE Fpq_a 
            DELETE Fpq_b 
         endif

         DELETE FTpq_a  
         DELETE FTpq_b  
         DELETE CBT_a 
         DELETE CBT_b 
#
      ENDDO kiter 
#
#     Release unneeded memory blocks.
#
      sip_barrier
      DELETE DHFA
      DELETE DHFB
      DELETE DHFA_OLD
      DELETE DHFB_OLD

      CREATE FTa 
      CREATE FTb 
      sip_barrier 
      PARDO mu, nu 
            GET Fpq_a[mu,nu] 
            DO p 
               Txp[mu,p] = Fpq_a[mu,nu]*ca[nu,p] 
               DO p1 
                  tpx[p1,mu] = ca[mu,p1] 
                  Tpp[p1,p] = ca[mu,p1]*Txp[mu,p] # *ca(mu,p1) 
                  PUT FTa[p1,p] += Tpp[p1,p] 
               ENDDO p1  
            ENDDO p 
      ENDPARDO mu, nu  
#     
      sip_barrier 
#
#     Put the final Fock arrays into predefined arrays 
#     ------------------------------------------------ 
#
      DO p
      DO p1
         GET            FTa[p,p1]
         Fock_a[p,p1] = FTa[p,p1]
      ENDDO p1
      ENDDO p
#
      sip_barrier

     #VFL execute print_rel_info two pinf
     #VFL execute print_rel_info three Fock_a
      execute get_my_rank rank
      if rank == 0.0
         DO mu
         DO p
            txp[mu,p] = ca[mu,p]
         ENDDO p
         ENDDO mu
      #VFL execute print_rel_info zero ca
      endif


      scfeneg  = energy2
      totenerg = scfeneg
      sip_barrier
#
#     Start the mp2 calculation  
#     ------------------------------------------------ 

      CALL TRAN_XXOO 
      CALL MP2_RHF
      sip_barrier 

#
                           ENDSIAL SCF_MP2_RHF         
#
###############################################################################
#
