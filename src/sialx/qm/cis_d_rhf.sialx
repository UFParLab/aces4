#  Copyright (c) 2003-2010 University of Florida
import "cis_rhf_defs.sialx" 
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
                           SIAL CIS_D_RHF
#
#-------------------------------------------------------------------------------
#
# Declare indeces 
# --------------- 
#
      index kiter    = 1: cc_iter   
      index kstate   = 1: eom_roots
      index kstate1  = 1: eom_roots
      index ksub  = 1: eom_subspc
      index ksub1 = 1: eom_subspc
#
      aoindex mu     = 1: norb 
      aoindex nu     = 1: norb
      aoindex lambda = 1: norb
      aoindex sigma  = 1: norb
#
      moaindex i = baocc: eaocc
      moaindex i1= baocc: eaocc
      moaindex i2= baocc: eaocc
      moaindex i3= baocc: eaocc
#
      moaindex a = bavirt: eavirt
      moaindex a1= bavirt: eavirt
      moaindex a2= bavirt: eavirt
      moaindex a3= bavirt: eavirt
#
      moaindex j = baocc: eaocc
      moaindex j1= baocc: eaocc
      moaindex j2= baocc: eaocc
      moaindex j3= baocc: eaocc
#
      moaindex b = bavirt: eavirt
      moaindex b1= bavirt: eavirt
      moaindex b2= bavirt: eavirt
      moaindex b3= bavirt: eavirt
#
      moaindex p = baocc: eavirt
      moaindex p1= baocc: eavirt
      moaindex p2= baocc: eavirt
      moaindex p3= baocc: eavirt
#
      moaindex q = baocc: eavirt
      moaindex q1= baocc: eavirt
      moaindex q2= baocc: eavirt
      moaindex q3= baocc: eavirt
# 
      scalar shift
      scalar ecorrab
      scalar esumab
      scalar ecorrT
      scalar ecorr2
      scalar rank
      scalar etemp
      scalar esum2
      scalar esum3
      scalar edoubles
      scalar etriples
      scalar ecis_d
      scalar kroot
#
      static ca[mu,p] 
      static fock_a[p,p1] 
      static Ek[kstate]
      static Ekd[kstate]
#
      served ck0[kstate,a,i]
      served Cai[a,i]
      static SCai[a,i]
      served Cai_ao[mu,i]
      served T2old_ab[a,i,b,j]
      served T2old_aa[a,i,b,j]
      served Ctau[a,i,b,j]
      served Ctau_ao[mu,i,lambda,j]
      served CT_ab[a,i,b,j]
      served Vxxxi[mu,nu,lambda,i]
      served Vxixi[mu,i1,lambda,i]
      served Vxxii[mu,nu,i1,i]
      served Vixxi[i1,nu,lambda,i]
      served Vxipi[mu,i,p,i1]
      served VSpipi[p1,i,p,i1]
      served Vixai[i,mu,a,i1]
      served Vxaii[mu,a,i,i1]
      served Viaai[i,a1,a,i1]
      served Vaaii[a,a1,i,i1]
      served Vxaai[mu,a1,a,i]
      served Vxxai[mu,nu,a,i]
      served Vaaai[a2,a,a1,i]
      served VSaaai[a2,a,a1,i]
      served SFai[a,i]
      served Vxixj[mu,i,nu,j]
      served Vxiqj[mu,i,q,j]
      served Vpiqj[p,i,q,j]
      served Faa[a,a1]
      served Fii[i,i1]
      served Fai[a,i]
#
      temp Tpp[p,p1]
      temp T1pp[p,p1]
      temp T2pp[p,p1]
      temp aoint[mu,nu,lambda,sigma]
      temp Taibj[a,i,b,j]
      temp T1aibj[a,i,b,j]
      temp T2aibj[a,i,b,j]
      temp Taiai[a,i,b,j]
      temp T1aiai[a,i,b,j]
      temp T2aiai[a,i,b,j]
      temp Tk[kstate]
      temp Tai[a,i]
      temp Txi[mu,i]
      temp Tkai[kstate,a,i]
      temp T1kai[kstate,a,i]
      temp Txixi[mu,i1,lambda,i]
      temp Taixj[a,i,mu,j]
      temp Txxii[mu,nu,i1,i]
      temp Tixxi[i1,nu,lambda,i]
      temp Txipi[mu,i,p,i1]
      temp T1xipi[mu,i,p,i1]
      temp Tpipi[p1,i,p,i1]
      temp T1pipi[p1,i,p,i1]
      temp Tixai[i,mu,a,i1]
      temp Txaii[mu,a,i,i1]
      temp Tiaai[i,a1,a,i1]
      temp Taaii[a,a1,i,i1]
      temp Txaai[mu,a1,a,i]
      temp Taaai[a2,a,a1,i]
      temp Txxai[mu,nu,a,i]
      temp T1xaai[mu,a1,a,i] 
      temp T1xxxi[mu,nu,lambda,i]  
      temp T1xixi[mu,i,nu,i1]
      temp Txiix[mu,i,i1,nu]
      temp Txpii[mu,p,i,i1]
      temp Tppii[p,p1,i,i1]
      temp Tixpi[i,mu,p,i1]
      temp Tippi[i,p,p1,i1]
#
      local Lxxxi[mu,nu,lambda,i]
      local Lxxai[mu,nu,a,i] 
      local Lxaai[mu,a1,a,i] 
      local LDaixj[a,i,nu,j]
##########################################
#
#
     PROC TRAN_TRAN2
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, lambda
#
          allocate Lxxxi[mu,nu,lambda,*]
#     
          DO sigma
#
             execute compute_integral_batch aoint[mu,nu,lambda,sigma]
#
             DO i   
#
                 T1xxxi[mu,nu,lambda,i]  = aoint[mu,nu,lambda,sigma]*ca[sigma,i]
                 Lxxxi[mu,nu,lambda,i]  += T1xxxi[mu,nu,lambda,i]
#    
             ENDDO i
#    
          ENDDO sigma

          DO i
           DO i1
              Txxii[mu,nu,i1,i]          = Lxxxi[mu,nu,lambda,i]*ca[lambda,i1]
              PREPARE Vxxii[mu,nu,i1,i] += Txxii[mu,nu,i1,i]
           ENDDO i1
           ENDDO i
#
          DO i
           DO i1
              Txixi[mu,i1,lambda,i]      = Lxxxi[mu,nu,lambda,i]*ca[nu,i1]
              PREPARE Vxixi[mu,i1,lambda,i] += Txixi[mu,i1,lambda,i]
           ENDDO i1
           ENDDO i
#
          DO i
           DO i1
              Tixxi[i1,nu,lambda,i]      = Lxxxi[mu,nu,lambda,i]*ca[mu,i1]
              PREPARE Vixxi[i1,nu,lambda,i] += Tixxi[i1,nu,lambda,i]
           ENDDO i1
           ENDDO i
#    
#          DO i
#           DO a
#              Txxai(mu,nu,a,i)          = Lxxxi(mu,nu,lambda,i)*ca(lambda,a)
#              PREPARE Vxxai(mu,nu,a,i) += Txxai(mu,nu,a,i)
#           ENDDO a
#           ENDDO i
#
          deallocate Lxxxi[mu,nu,lambda,*]
#
     ENDPARDO mu, nu, lambda
     server_barrier
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_TRAN2
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
#    Perform the third N5 stage of the transformation.
#
     PROC TRAN_TRAN3
#
#    ------------------------------------------------------------------------
#
     PARDO mu, nu, i, i1
#
           REQUEST Vxixi[mu,i,nu,i1] 
#
           DO p
#
              Txipi[mu,i,p,i1]          = Vxixi[mu,i,nu,i1]*ca[nu,p]
              PREPARE Vxipi[mu,i,p,i1] += Txipi[mu,i,p,i1]
#
           ENDDO p
#
     ENDPARDO mu, nu, i, i1
#
     PARDO mu, nu, i, i1
#
           REQUEST Vxxii[mu,nu,i,i1] 
#
           DO a
#
              Txaii[mu,a,i,i1]          = Vxxii[mu,nu,i,i1]*ca[nu,a]
              PREPARE Vxaii[mu,a,i,i1] += Txaii[mu,a,i,i1]

           ENDDO a
#
     ENDPARDO mu, nu, i, i1
#
     PARDO mu, nu, i, i1
#
           REQUEST Vixxi[i,mu,nu,i1] 
#
           DO a
#
              Tixai[i,mu,a,i1]          = Vixxi[i,mu,nu,i1]*ca[nu,a]
              PREPARE Vixai[i,mu,a,i1] += Tixai[i,mu,a,i1]
#
           ENDDO a

     ENDPARDO mu, nu, i, i1
#
#     pardo mu,nu,a,i
#         request Vxxai(mu,nu,a,i) i
#         do a1
#             Txaai(mu,a1,a,i) = Vxxai(mu,nu,a,i)*Ca(nu,a1)
#             prepare Vxaai(mu,a1,a,i) += Txaai(mu,a1,a,i)
#         enddo a1
#     endpardo mu,nu,a,i
#
#    ------------------------------------------------------------------------
#
     server_barrier
#
     ENDPROC TRAN_TRAN3
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_TRAN4
#
#    ------------------------------------------------------------------------
#
     PARDO mu, p, i, i1
#
           REQUEST             Vxipi[mu,i,p,i1] 
           REQUEST             Vxipi[mu,i1,p,i] 
           Txipi[mu,i,p,i1]  = Vxipi[mu,i,p,i1]
           T1xipi[mu,i,p,i1] = Vxipi[mu,i1,p,i]
           Txipi[mu,i,p,i1] -= T1xipi[mu,i,p,i1]
#
           DO p1
#
              Tpipi[p1,i,p,i1]          = Vxipi[mu,i,p,i1]*ca[mu,p1]
              PREPARE Vpiqj[p1,i,p,i1] += Tpipi[p1,i,p,i1]
#
           ENDDO p1
#
           DO p1
#
              Tpipi[p1,i,p,i1]          = Txipi[mu,i,p,i1]*ca[mu,p1]
              PREPARE VSpipi[p1,i,p,i1] += Tpipi[p1,i,p,i1]
#
           ENDDO p1
#
     ENDPARDO mu, p, i, i1
#
     PARDO mu, a, i, i1
#
           REQUEST Vxaii[mu,a,i,i1] 
           REQUEST Vixai[i,mu,a,i1] 
#
           DO a1
#
              Taaii[a1,a,i,i1]          = Vxaii[mu,a,i,i1]*ca[mu,a1]
              PREPARE Vaaii[a1,a,i,i1] += Taaii[a1,a,i,i1]
#
           ENDDO a1
#
           DO a1
#
              Tiaai[i,a1,a,i1]          = Vixai[i,mu,a,i1]*ca[mu,a1]
              PREPARE Viaai[i,a1,a,i1] += Tiaai[i,a1,a,i1]
#
           ENDDO a1
#
     ENDPARDO mu, a, i, i1
#
#         pardo mu, a, a1, i
#             request Vxaai(mu,a,a1,i) i
#             do a2
#                 Taaai(a2,a,a1,i) = Vxaai(mu,a,a1,i)*Ca(mu,a2)
#                 prepare Vaaai(a2,a,a1,i) += Taaai(a2,a,a1,i)
#             enddo a2
#         endpardo mu, a, a1, i

         server_barrier
#
#    ------------------------------------------------------------------------
#
     ENDPROC TRAN_TRAN4
#
#    ------------------------------------------------------------------------
#
#    ------------------------------------------------------------------------
#
     PROC TRAN_UHF
#
#        CALL COMP_INTEGRALS # --> compute integrals and put into served array
         CALL TRAN_TRAN2     # --> performs the first two stages of the
                             #     two-electron integral transformation.
         CALL TRAN_TRAN3     # --> performs the third stage
                             #     two-electron integral transformation.
         CALL TRAN_TRAN4     # --> performs the fourth stage of the
                             #     two-electron integral transformation.
#
     ENDPROC TRAN_UHF
#
      proc setroot
#
#      pardo a,i
#          Tai(a,i) = 0.0
#          prepare Cai(a,i) = Tai(a,i)
#      endpardo a,i
#      server_barrier
      Tk[kstate] = 1.0
#      pardo a,i
#          request ck0(kstate,a,i) i
#          Tai(a,i) = ck0(kstate,a,i)*Tk(kstate)
#          prepare Cai(a,i) = Tai(a,i)
#      endpardo a,i
      do a
      do i
          request ck0[kstate,a,i] 
          Tai[a,i] = ck0[kstate,a,i]*Tk[kstate]
          SCai[a,i] = Tai[a,i]
      enddo i
      enddo a
      server_barrier
      endproc setroot
#
     PROC IGUESS_UHF  
# 
#    ------------------------------------------------------------------------ 
#
     server_barrier
     PARDO a, b, i, j 
#
           REQUEST                     Vpiqj[a,i,b,j]   
           REQUEST                     Vpiqj[b,j,a,i]   
           Taibj[a,i,b,j]            = Vpiqj[b,j,a,i]
           Taibj[a,i,b,j]           += Vpiqj[a,i,b,j]
           execute energy_denominator_rhf  Taibj[a,i,b,j] fock_a  
           Taibj[a,i,b,j]           *= 0.5  
           PREPARE T2old_ab[a,i,b,j] = Taibj[a,i,b,j]  
#
     ENDPARDO a, b, i, j 
     server_barrier
         pardo a,i,b,j
             request T2old_ab[a,i,b,j] 
             request T2old_ab[a,j,b,i] 
             Taibj[a,i,b,j]  = T2old_ab[a,i,b,j]
             T1aibj[a,i,b,j] = T2old_ab[a,j,b,i]
             Taibj[a,i,b,j] -= T1aibj[a,i,b,j]
             prepare T2old_aa[a,i,b,j] = Taibj[a,i,b,j]
         endpardo a,i,b,j
     server_barrier
#
#    ------------------------------------------------------------------------ 
# 
     ENDPROC IGUESS_UHF 
#
     PROC ENERGY_NEW 
# 
#    ------------------------------------------------------------------------ 
#
     ecorrab = 0.0 
     esumab  = 0.0 
     server_barrier 
     PARDO a, b, i, j 
#
           REQUEST Vpiqj[a,i,b,j]   
           REQUEST Vpiqj[a,j,b,i]   
#
           REQUEST T2old_ab[a,i,b,j]   
#
           Taibj[a,i,b,j] = T2old_ab[a,i,b,j]  
#
           T1aibj[a,i,b,j] = Vpiqj[a,i,b,j]  
           T2aibj[a,i,b,j] = Vpiqj[a,j,b,i]  
           T1aibj[a,i,b,j]*= 2.0  
           T1aibj[a,i,b,j]-= T2aibj[a,i,b,j]  
#
           etemp = Taibj[a,i,b,j]*T1aibj[a,i,b,j] 
           esumab += etemp 
#
     ENDPARDO a, b, i, j 

     server_barrier 
#
     collective ecorrab += esumab
     ecorrT = ecorrab 
      print ecorrab
      server_barrier

#    ------------------------------------------------------------------------ 
# 
     ENDPROC ENERGY_NEW 
#
     proc Caibj
#
     pardo a,i,b,j
         Taiai[a,i,b,j] = 0.0
         prepare Ctau[a,i,b,j] = Taiai[a,i,b,j]
         prepare CT_ab[a,i,b,j] = Taiai[a,i,b,j]
     endpardo a,i,b,j
     pardo mu,i
         Txi[mu,i] = 0.0
         prepare Cai_ao[mu,i] = Txi[mu,i]
     endpardo mu,i
     pardo mu,i,lambda,j
         Txixi[mu,i,lambda,j] = 0.0
         prepare Ctau_ao[mu,i,lambda,j] = Txixi[mu,i,lambda,j]
     endpardo mu,i,lambda,j
     server_barrier
#
# back transform CIS vector
     pardo a,i
#         request Cai(a,i) i
         do mu
             Txi[mu,i] = SCai[a,i]*ca[mu,a]
             prepare Cai_ao[mu,i] += Txi[mu,i]
         enddo mu
     endpardo a,i
#
     server_barrier
#
     pardo mu,nu,lambda

          allocate Lxxxi[mu,nu,lambda,*]
          DO sigma
             execute compute_integral_batch aoint[mu,nu,lambda,sigma]
             DO i   
                 T1xxxi[mu,nu,lambda,i]  = aoint[mu,nu,lambda,sigma]*ca[sigma,i]
                 Lxxxi[mu,nu,lambda,i]  += T1xxxi[mu,nu,lambda,i]
             ENDDO i
          ENDDO sigma

          do i
              request Cai_ao[nu,i] 
          do j

              Txixi[mu,i,lambda,j] = Cai_ao[nu,i]*Lxxxi[mu,nu,lambda,j]
              prepare Ctau_ao[mu,i,lambda,j] += Txixi[mu,i,lambda,j]

          enddo j
          enddo i

          deallocate Lxxxi[mu,nu,lambda,*]

     endpardo mu,nu,lambda
#
     server_barrier
     pardo a,i,b,j
         Taiai[a,i,b,j] = 0.0
         do i1
             request Vpiqj[i1,i,b,j] 
#             request cai(a,i1) a
             T1aiai[a,i,b,j] = Vpiqj[i1,i,b,j]*SCai[a,i1]
             Taiai[a,i,b,j] += T1aiai[a,i,b,j]
         enddo i1
         Taiai[a,i,b,j] *= -1.0
         prepare Ctau[a,i,b,j] += Taiai[a,i,b,j]
     endpardo a,i,b,j

     pardo nu,i,j

              allocate LDaixj[*,i,nu,j]
#
              DO mu
#
                 REQUEST Ctau_ao[mu,i,nu,j] 
#
                 DO a
                    Taixj[a,i,nu,j]   = Ctau_ao[mu,i,nu,j]*ca[mu,a]
                    LDaixj[a,i,nu,j] += Taixj[a,i,nu,j]
                 ENDDO a
#
              ENDDO mu

              DO a
              DO b
                 Taibj[a,i,b,j]             = LDaixj[a,i,nu,j]*ca[nu,b]
                 PREPARE Ctau[a,i,b,j] += Taibj[a,i,b,j]
              ENDDO b
              ENDDO a
#
              deallocate LDaixj[*,i,nu,j]

     endpardo nu,i,j

     server_barrier
     pardo a,i,b,j
         request Ctau[a,i,b,j] 
         request Ctau[b,j,a,i] 
         Taiai[a,i,b,j]  = Ctau[a,i,b,j]
         T1aiai[a,i,b,j] = Ctau[b,j,a,i]
         Taiai[a,i,b,j] += T1aiai[a,i,b,j]
         prepare CT_ab[a,i,b,j] = Taiai[a,i,b,j]
     endpardo a,i,b,j
     server_barrier
#
     endproc Caibj
#
     proc hbar_ab
#
     pardo a,i,b,j
#
         Tpp[a,b] = 0.0
         do a1
             request VSpipi[b,i,a1,j] 
             request T2old_aa[a,i,a1,j] 
             T1pp[a,b] = VSpipi[b,i,a1,j]*T2old_aa[a,i,a1,j]
             Tpp[a,b] += T1pp[a,b]
         enddo a1
         Tpp[a,b] *= -0.5
         prepare Faa[a,b] += Tpp[a,b]
#
     endpardo a,i,b,j
     pardo a,i,b,j
#
         Tpp[a,b] = 0.0
         do a1
             request Vpiqj[b,i,a1,j] 
             request T2old_ab[a,i,a1,j] 
             T1pp[a,b] = Vpiqj[b,i,a1,j]*T2old_ab[a,i,a1,j]
             Tpp[a,b] += T1pp[a,b]
         enddo a1
         Tpp[a,b] *= -1.0
         prepare Faa[a,b] += Tpp[a,b]
#
     endpardo a,i,b,j
#
     server_barrier
     endproc hbar_ab
#
     proc hbar_ij
#
     pardo a,i,b,j
#
         Tpp[i,j] = 0.0
         do i1
             request VSpipi[a,j,b,i1] 
             request T2old_aa[a,i,b,i1] 
             T1pp[i,j] = VSpipi[a,j,b,i1]*T2old_aa[a,i,b,i1]
             Tpp[i,j] += T1pp[i,j]
         enddo i1
         Tpp[i,j] *= -0.5
         prepare Fii[i,j] += Tpp[i,j]
#
     endpardo a,i,b,j
     pardo a,i,b,j
#
         Tpp[i,j] = 0.0
         do i1
             request Vpiqj[a,j,b,i1] 
             request T2old_ab[a,i,b,i1] 
             T1pp[i,j] = Vpiqj[a,j,b,i1]*T2old_ab[a,i,b,i1]
             Tpp[i,j] += T1pp[i,j]
         enddo i1
         Tpp[i,j] *= -1.0
         prepare Fii[i,j] += Tpp[i,j]
#
     endpardo a,i,b,j
#
     server_barrier
     endproc hbar_ij
#
     proc hbar_ai

     pardo a,i,a1,i1
         request VSpipi[a,i,a1,i1] 

         Taibj[a,i,a1,i1] = VSpipi[a,i,a1,i1]
         T1pp[a1,i1]      = SCai[a1,i1]
         Tpp[a,i]         = Taibj[a,i,a1,i1]*T1pp[a1,i1]

         prepare SFai[a,i] += Tpp[a,i]
     endpardo a,i,a1,i1
     pardo a,i,a1,i1
         request Vpiqj[a,i,a1,i1] 

         Taibj[a,i,a1,i1] = Vpiqj[a,i,a1,i1]
         T1pp[a1,i1]      = SCai[a1,i1]
         Tpp[a,i]         = Taibj[a,i,a1,i1]*T1pp[a1,i1]

         prepare SFai[a,i] += Tpp[a,i]
     endpardo a,i,a1,i1
     server_barrier
     pardo a,i,a1,i1
         request T2old_aa[a,i,a1,i1] 
         request SFai[a1,i1] 
         Taibj[a,i,a1,i1] = T2old_aa[a,i,a1,i1]
         T1pp[a1,i1]      = SFai[a1,i1]
         Tpp[a,i]         = Taibj[a,i,a1,i1]*T1pp[a1,i1]
         prepare Fai[a,i] += Tpp[a,i]
     endpardo a,i,a1,i1
     pardo a,i,a1,i1
         request T2old_ab[a,i,a1,i1] 
         request SFai[a1,i1] 
         Taibj[a,i,a1,i1] = T2old_ab[a,i,a1,i1]
         T1pp[a1,i1]      = SFai[a1,i1]
         Tpp[a,i]         = Taibj[a,i,a1,i1]*T1pp[a1,i1]
         prepare Fai[a,i] += Tpp[a,i]
     endpardo a,i,a1,i1
     server_barrier
#
     endproc hbar_ai
#
     proc hbar_prep
         server_barrier
         pardo a,b
             Tpp[a,b] = 0.0
             prepare Faa[a,b] = Tpp[a,b]
         endpardo a,b
         pardo i,j
             Tpp[i,j] = 0.0
             prepare Fii[i,j] = Tpp[i,j]
         endpardo i,j
         pardo a,i
             Tpp[a,i] = 0.0
             prepare Fai[a,i] = Tpp[a,i]
         endpardo a,i
         pardo a,i
             Tpp[a,i] = 0.0
             prepare SFai[a,i] = Tpp[a,i]
         endpardo a,i
         server_barrier
     endproc hbar_prep
#
     proc make_hbar
#
     call hbar_prep
     call hbar_ab
     call hbar_ij
     call hbar_ai
     server_barrier
#
     endproc make_hbar
#
     proc cisd_energy
#
     server_barrier
     esum2 = 0.0
     esum3 = 0.0
     ecorr2 = 0.0
     edoubles = 0.0
     etriples = 0.0
     ecis_d = 0.0
     server_barrier
#
     pardo a,i,b,j
         REQUEST CT_ab[a,i,b,j] 
         REQUEST CT_ab[b,i,a,j] 
         Taibj[a,i,b,j]  = CT_ab[a,i,b,j]
         T1aibj[a,i,b,j] = CT_ab[b,i,a,j]
         Taibj[a,i,b,j] *= 2.0
         Taibj[a,i,b,j] -= T1aibj[a,i,b,j]
#
         execute energy_ty_denominator_rhf Taibj[a,i,b,j] fock_a shift
         etemp  = Taibj[a,i,b,j]*CT_ab[a,i,b,j]
         etemp *= 0.5
         esum2 += etemp
     endpardo a,i,b,j
     pardo a,i
#         request cai(a,i) i
         request Fai[a,i] 
         Tpp[a,i] = Fai[a,i]
#
         do b
             request Faa[a,b] 
#             request cai(b,i) i
             T1pp[a,i] = Faa[a,b]*SCai[b,i]
             Tpp[a,i] += T1pp[a,i]
         enddo b
#
         do j
             request Fii[i,j] 
#             request cai(a,j) a
             T1pp[a,i] = Fii[i,j]*SCai[a,j]
             Tpp[a,i] += T1pp[a,i]
         enddo j
#
         etemp = SCai[a,i]*tpp[a,i]
         esum3+= etemp
#
     endpardo a,i
     server_barrier
#
     collective edoubles += esum2
     collective etriples += esum3
     server_barrier
     ecis_d  = edoubles
     ecis_d += etriples
     Ekd[kstate] = ecis_d
     execute get_my_rank rank
     if rank == 0.0
         print edoubles
         print etriples
         print ecis_d
     endif #rank == 0.0
#
     endproc cisd_energy
# 
##########################################
# MAIN
##########################################
      sip_barrier
#
      execute get_my_rank rank
      if rank == 0.0
      println "starting CIS(D)"
      endif
#
      restore_persistent ca "ca"
      restore_persistent Fock_a "fock_a"
      restore_persistent ck0 "Ck0"
      restore_persistent Ek "CEk"
      server_barrier
#      call tran_uhf
      restore_persistent     Viaai  "Viaai"
      restore_persistent     Vaaii  "Vaaii"
      restore_persistent     Vpiqj  "Vpiqj"
      restore_persistent     VSpipi "VSpipi"
      server_barrier
#
      call iguess_uhf
      call energy_new
#
      kroot = 1.0
      do kstate
          server_barrier
          println " "
          print kroot
#
          execute return_sval Ek[kstate] shift
          server_barrier
          call setroot
          call Caibj
          call make_hbar
          call cisd_energy
          server_barrier
#
          kroot += 1.0
#
      enddo kstate
      execute get_my_rank rank
      if rank == 0.0
          execute print_static_array Ekd
      endif
#
      server_barrier
      set_persistent     ca    "ca" 
      set_persistent     Fock_a "fock_a"
      set_persistent     ck0 "Ck0"
      set_persistent     Ek "CEk"
#
      set_persistent Viaai  "Viaai"
      set_persistent Vaaii  "Vaaii"
      set_persistent Vpiqj  "Vpiqj"
      set_persistent VSpipi "VSpipi"
###########################################
                           ENDSIAL CIS_D_RHF
