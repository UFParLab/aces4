#  Copyright (c) 2003-2010 University of Florida
import "scf_defs.sialx"
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
#
                           SIAL SCF_RHF_COREH          
#
# ----------------------------------------------------------------------------
#
# The sial program SIAL_UHF performs a UHF based SCF calculation. Davidson 
# damping is performed during the first scf_beg-1 iterations after which the 
# DIIS is turned on with scf_order. At present DIIS is turned on after the 
# third iteration and 6 histories are kept. 
#

# Fock matrix final arrays:
# ------------------------- 
#
# 1. Fpq_a  
# 2. Fpq_b  
#
# Transformation coefficients final arrays:
# ----------------------------------------- 
#
# 1. Ca  
# 2. Cb  
#
# Converged SCF energy:
# --------------------- 
#
# 1. scf_energy 
#
# BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
#
# Declare indices 
# --------------- 
#
#
      index   kiter  = 1: scf_iter  
      index   kbeg   = 1: scf_beg
      index   korder = 1: scf_hist
      index   kptr1  = 1: 2
      index   kptr2  = 1: 2
      index   kone   = 1: 1
      index   kdiis  = 1: 30 
      index   d1     = 1: 30 
      index   d2     = 1: 30 
      index   d3     = 1: 30 
      index   d4     = 1: 30 
      index   iiter1 = 1: 1
      index   jjter1 = 1: 1
      index   jjter2 = 2: 2
      index   g51    = 1: 5000 
      index   g52    = 1: 5000 
      index   ixyz   = 1: 3
#
      aoindex mu     = 1: norb
      aoindex nu     = 1: norb
      aoindex lambda = 1: norb
      aoindex sigma  = 1: norb
#
      moaindex i = baocc: eaocc
      moaindex i1= baocc: eaocc
      moaindex i2= baocc: eaocc
      moaindex i3= baocc: eaocc
#
      moaindex a = bavirt: eavirt
      moaindex a1= bavirt: eavirt
      moaindex a2= bavirt: eavirt
      moaindex a3= bavirt: eavirt
#
      moaindex j = baocc: eaocc
      moaindex j1= baocc: eaocc
      moaindex j2= baocc: eaocc
      moaindex j3= baocc: eaocc
#
      moaindex b = bavirt: eavirt
      moaindex b1= bavirt: eavirt
      moaindex b2= bavirt: eavirt
      moaindex b3= bavirt: eavirt
#
      moaindex p = baocc: eavirt
      moaindex p1= baocc: eavirt
      moaindex p2= baocc: eavirt
      moaindex p3= baocc: eavirt
#
      moaindex q = baocc: eavirt
      moaindex q1= baocc: eavirt
      moaindex q2= baocc: eavirt
      moaindex q3= baocc: eavirt
# 
# Declare one-particle density arrays 
# ----------------------------------- 
#
      distributed Dhfa[mu,nu] 
      distributed Dhfb[mu,nu] 
      distributed Dhfa_old[mu,nu] 
      distributed Dhfb_old[mu,nu] 
#
      distributed Fpq_a[mu,nu] 
      distributed Fpq_b[mu,nu] 
      distributed FTpq_a[mu,nu] 
      distributed FTpq_b[mu,nu] 
      distributed CBT_a[mu,p] 
      distributed CBT_b[mu,q] 
      distributed Dca[mu,p]  

      static dflags11[iiter1,jjter1]
      static dflags12[iiter1,jjter2]
      static screen_array[g51,g52] 
#
# Declare temporary arrays 
# ------------------------ 
#
      temp Ixi[mu,i] 
      temp I1xi[mu,i] 
      temp Ixj[mu,j] 
      temp I1xj[mu,j] 
      temp Tpq[mu,nu] 
      temp T1pq[mu,nu] 
      temp Txi[mu,i] 
      temp T1xi[mu,i] 
      temp Txj[mu,j] 
      temp T1xj[mu,j] 
      temp Txx[mu,nu] 
      temp TAxx[mu,nu] 
      temp TBxx[mu,nu] 
      temp T1xx[mu,nu] 
      temp T2xx[mu,nu] 
      temp T3xx[mu,nu] 
      temp T4xx[mu,nu] 
      temp T5xx[mu,nu] 
      temp T6xx[mu,nu] 
      temp T7xx[mu,nu] 
      temp T8xx[mu,nu] 
      temp T9xx[mu,nu] 
      temp T10xx[mu,nu] 
      temp T11xx[mu,nu] 
      temp T12xx[mu,nu] 
      temp T13xx[mu,nu] 
      temp T14xx[mu,nu] 
      temp T15xx[mu,nu] 
      temp T16xx[mu,nu] 
      temp T17xx[mu,nu] 
      temp T18xx[mu,nu] 
      temp T19xx[mu,nu] 
      temp T20xx[mu,nu] 
      temp T21xx[mu,nu] 
      temp T22xx[mu,nu] 
      temp Tii[i,i1] 
      temp T1ii[i,i1] 
      temp Tjj[j,j1] 
      temp T1jj[j,j1] 
      temp Txp[mu,p] 
      temp T1xp[mu,p] 
      temp Tpp[p,p1] 
      temp T1pp[p,p1] 
      temp Txq[mu,q] 
      temp T1xq[mu,q] 
      temp Tqq[q,q1] 
      temp T1qq[q,q1] 
#
# Declare served arrays 
# --------------------- 
#
      temp aoint[mu,nu,lambda,sigma]
#
# Declare static arrays 
# --------------------- 
#
      static FSpq_a[mu,nu] 
      static FSpq_b[mu,nu] 
      distributed Qxx[mu,nu] 
      distributed FTa[p,p1] 
      distributed FTb[q,q1] 
      static X1[mu,nu] 
      local LDHFa[mu,nu] 
      local LDHFb[mu,nu] 
      local LFpq_b[mu,nu] 
      local LFpq_a[mu,nu] 
      static pinf[kiter,kptr1]
      temp tpinf[kiter,kptr1]
#
# Arrays used in DIIS procedure 
# ----------------------------- 
#  
      distributed FFai[a,i] 
      distributed FFbj[b,j] 
      temp tai[a,i] 
      temp t1ai[a,i] 
      temp tbj[b,j] 
      temp t1bj[b,j] 
      scalar dens_check 
      scalar pcount 
      scalar zmax 
      scalar imax 
      scalar repulsion
#
# Declare scalars 
# --------------- 
#
      scalar num_lindep
      scalar e_a     
      scalar e_b     
      scalar escf_a 
      scalar escf_b 
      scalar etemp 
      scalar esum 
      scalar esum1
      scalar energy 
      scalar energy1 
      scalar energy2 
      scalar ecrit 
      scalar ediff  
#     scalar damp 
      scalar damp1 
      scalar done 
      scalar donea 
      scalar doneb 
   
      scalar zero 
      scalar mone 
      scalar one
      scalar two
      scalar three
      scalar four
      scalar ncount1 
      scalar rank 
#
# Parameters needed for DIIS 

      scalar diis_start  
      scalar diis_end   
      scalar diis_order   
      scalar diis_max_order # same as kdiis   
      scalar diis_count 
      scalar temp_order   
      scalar worder  
      scalar n1 
      scalar n2 

      distributed Fa[mu,nu,kdiis] 
      distributed Fb[mu,nu,kdiis] 
      distributed Fbj[b,j,kdiis] 
      distributed Fai[a,i,kdiis] 
      temp tpqx[mu,nu,d2]   
      temp taix[a,i,d2]   
      temp tbjx[b,j,d2]   
      temp tdd[d1,d2] 
      temp t1dd[d1,d2] 
      static BB[d1,d2] 

      temp DAOINT[mu,nu]
      static dipole[ixyz]
      static NucDip[ixyz]
      static Dip02[ixyz]
      served Dxx_scf[mu,nu]
      scalar dsum
      scalar AbsDip
      scalar ncount2
#
# ---------------------------------------------------------------------------- 
#
# -----------------------------------------------------------------------------
#
      PROC HFDENS
#     -----------
#
#     The HF density is computed. Davidson damping is incorporated thus
#     knowledge of the previous iteration is needed. 
#     ----------------------------------------------------------------- 
#
      PARDO mu, nu 
#
#           alpha component first 
#           --------------------- 
#
            GET           DHFa_old[mu,nu] 
            GET           DHFb_old[mu,nu] 
            Tpq[mu,nu]  = DHFa_old[mu,nu]   
            Tpq[mu,nu] *= damp  
#
            DO i 
#
               Txi[nu,i]   = ca[nu,i]
               T1pq[mu,nu] = Txi[nu,i]*ca[mu,i]
               Tpq[mu,nu] += T1pq[mu,nu] 
#
            ENDDO i 
#
            Tpq[mu,nu]     *= damp1   
            PUT Dhfa[mu,nu] = Tpq[mu,nu]
#
#           beta component next  
#           ------------------- 
#
            Tpq[mu,nu]  = DHFb_old[mu,nu]   
            Tpq[mu,nu] *= damp  
#
            DO j 
#
               Txj[nu,j]   = ca[nu,j]
               T1pq[mu,nu] = ca[mu,j]*Txj[nu,j]
               Tpq[mu,nu] += T1pq[mu,nu] 
#
            ENDDO j 
#
            Tpq[mu,nu]     *= damp1   
            PUT Dhfb[mu,nu] = Tpq[mu,nu]
#
      ENDPARDO mu, nu 
#
      ENDPROC HFDENS
#     --------------
#
# ---------------------------------------------------------------------------- 
#
# -----------------------------------------------------------------------------
#
      PROC HFIDENS
#     ------------
#
#     Procedure which computes the HF density without Davidson damping. 
#     ----------------------------------------------------------------- 
#
      PARDO mu, nu 
#
#           alpha component 
#           --------------- 
#
            Tpq[mu,nu] = 0.0 
#
            DO i 
#
               Txi[nu,i]   = ca[nu,i]
               T1pq[mu,nu] = Txi[nu,i]*ca[mu,i]
               Tpq[mu,nu] += T1pq[mu,nu] 
#
            ENDDO i 
# 
            PUT Dhfa[mu,nu] = Tpq[mu,nu]
#
#           beta component 
#           -------------- 
#
            Tpq[mu,nu] = 0.0 
#
            DO j 
#
               Txj[nu,j]   = ca[nu,j]
               T1pq[mu,nu] = ca[mu,j]*Txj[nu,j]
               Tpq[mu,nu] += T1pq[mu,nu] 
#
            ENDDO j 
#
            PUT Dhfb[mu,nu] = Tpq[mu,nu]
#
      ENDPARDO mu, nu 
#
      ENDPROC HFIDENS
#     ---------------
#
# ---------------------------------------------------------------------------- 
#
# ---------------------------------------------------------------------------- 
#

# ---------------------------------------------------------------------------- 
#
       PROC FOCK_MATRIX_FAST   
#      --------------------- 
#
#      The complete Fock matrix is constructed. Eight fold symmetry of the
#      two-electron integrals is incorporated. 
#      ------------------------------------------------------------------
#
#      Put the density into local arrays 
#      --------------------------------- 
#
#      Initialize the Fock matrix to the bare 1-electron hamiltonian.
#      -------------------------------------------------------------- 
#
       sip_barrier
       DO mu
       DO nu
#
          Txx[mu,nu]        = 0.0
          Fockrohf_a[mu,nu] = Txx[mu,nu]
          Fockrohf_b[mu,nu] = Txx[mu,nu]
       ENDDO nu
       ENDDO mu 

       sip_barrier
#
#      Add contributions containing two-particle integral contributions.
#      -----------------------------------------------------------------
#
############# CLASS 6  ############
##  Do four-center part (mu nu |la si)->(mu nu |si la ),(nu mu|la si),(nu mu|si la)
##                      (la si |mu nu),(si la |mu nu),(la si |nu mu),(si la |nu mu)
##
        PARDO mu, nu, lambda, sigma
##
                 WHERE mu      < nu
                 WHERE lambda  < sigma
                 WHERE mu     < lambda
                 WHERE nu     != sigma
                 WHERE nu     != lambda
                 WHERE mu     != sigma
##
                    execute compute_ubatch1 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
##
        ENDPARDO mu, nu, lambda, sigma
##
#
############ CLASS 3  ############
#  Do two-center part (mu mu |mu nu)->(mu nu |mu mu ),(mu mu|nu mu),(nu mu|mu mu)
#  Do three-center part (mu mu |nu lambda)->(mu mu |lambda nu ),(nu lambda|mu mu),(lambda nu|mu mu)
#
       PARDO mu, nu, lambda, sigma 
#
          WHERE mu == nu
          WHERE lambda  < sigma
#
                execute compute_ubatch2 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
#
       ENDPARDO mu, nu, lambda, sigma 
#
############ CLASS 5  ############
###################  CLASS A ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
#
#
       PARDO mu, nu, lambda, sigma
                WHERE nu < sigma
                WHERE mu < nu
                WHERE lambda < sigma
                WHERE mu==lambda
#
                   execute compute_ubatch4 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
#
       ENDPARDO mu, nu, lambda, sigma

###################  CLASS B ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
# 
      PARDO mu, nu, lambda, sigma 
                WHERE mu < nu
                WHERE lambda < sigma
                WHERE mu < sigma
                WHERE nu == lambda
#
                   execute compute_ubatch4 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
#
       ENDPARDO mu, nu, lambda, sigma
#
# 
###################  CLASS C ##############
#  Do three-center part (mu nu |mu la)->(mu nu |la mu ),(nu mu|mu la),(nu mu|la mu)
#                       (mu la |mu nu),(la mu |mu nu ),(mu la |nu mu),(la mu |nu mu)
#
       PARDO mu, nu, lambda, sigma
                WHERE mu < nu
                WHERE lambda < sigma
                WHERE mu < lambda
                WHERE nu == sigma
#
                   execute compute_ubatch4 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
#
       ENDPARDO mu, nu, lambda, sigma
#
############ CLASS 4  ############
#  Do two-center part (mu nu |mu nu)->(mu nu |nu mu ),(nu mu|mu nu),(nu mu|nu mu)
#
       PARDO mu, nu, lambda, sigma
                WHERE mu < nu
                WHERE lambda < sigma 
                WHERE nu == sigma
                WHERE mu == lambda
#
                   execute compute_ubatch8 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
#
       ENDPARDO mu, nu, lambda, sigma
#
#          
############ CLASS 2  ############
#  Do two-center part (mu mu |nu nu)->(nu nu |mu mu )
#
       PARDO mu, nu, lambda, sigma
#
             WHERE mu < lambda
             WHERE mu == nu
             WHERE lambda == sigma
#
                   execute compute_ubatch7 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
#
       ENDPARDO mu, nu, lambda, sigma 
#
############ END CLASS 2  ############
#
#
############ CLASS 1  ############
#  Do one-center part (mu mu |mu mu)
#
       PARDO mu, nu, lambda, sigma
             WHERE nu == mu
             WHERE sigma == mu
             WHERE lambda == mu 
#
                   execute compute_ubatch6 aoint[mu,nu,lambda,sigma] oed_kin oed_ovl fockrohf_a fockrohf_b
#
       ENDPARDO mu, nu, lambda, sigma
#
############ END CLASS 1  ############
#
       sip_barrier
#      
       DO mu
       DO nu
#         
          Txx[mu,nu]        = Fockrohf_a[mu,nu]
          PUT Fpq_a[mu,nu] += Txx[mu,nu]
#      
       ENDDO nu
       ENDDO mu 
#      
       DO mu
       DO nu
#         
          Txx[mu,nu]        = Fockrohf_b[mu,nu]
          PUT Fpq_b[mu,nu] += Txx[mu,nu]
#      
       ENDDO nu
       ENDDO mu 
#
       sip_barrier
#
       execute get_my_rank rank  
       if rank == 0.0 
       DO mu    
       DO nu   
#
            execute return_h1 txx[mu,nu] 
#
            PUT Fpq_a[mu,nu] += Txx[mu,nu] 
            PUT Fpq_b[mu,nu] += Txx[mu,nu] 
#
       ENDDO nu   
       ENDDO mu    
       endif 
#
       ENDPROC FOCK_MATRIX_FAST   
#      ------------------------ 
#
# ---------------------------------------------------------------------------- 
#
#
       PROC HF_ENERGY  
#      -------------- 
#
#      The HF energy is computed from the HF density (DHFa(b)) and the 
#      Fock matrix (Fpq_a(b)). 
#      --------------------------------------------------------------- 
#
       energy = 0.0
       esum = 0.0 

       execute get_my_rank rank 
       if rank == 0.0 

          DO mu  
          DO nu 
#
             GET Fpq_a[mu,nu]
             GET Fpq_b[mu,nu]
             GET DHFa[mu,nu] 
             GET DHFb[mu,nu] 
#
             Txx[mu,nu]   = 0.0 
             execute return_h1 txx[mu,nu]  
#
             T1xx[mu,nu]  = Txx[mu,nu] 
             T1xx[mu,nu] += Fpq_a[mu,nu] 
#
             etemp        = T1xx[mu,nu]*DHFa[mu,nu]  
             esum        += etemp 
#
             T1xx[mu,nu]  = Txx[mu,nu] 
             T1xx[mu,nu] += Fpq_b[mu,nu] 
#
             etemp        = T1xx[mu,nu]*DHFb[mu,nu]  
             esum        += etemp 
#
          ENDDO nu 
          ENDDO mu 

       endif 


       sip_barrier 

       esum *= 0.5 
       collective energy += esum 
       energy += repulsion 
#
       #print_scalar esum  
        assert_same energy
        print energy 
#
       ENDPROC HF_ENERGY   
#      ----------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC OVER_HALF 
#      -------------- 
#
#      Diagonalize the overlap matrix, invert and take the square
#      root of the diagonal elements. 
#      -------------------------------------------------------------- 
#
       DO mu 
       DO nu 
          execute return_ovl txx[mu,nu] 
          oed_ovl[mu,nu] = txx[mu,nu]  
       ENDDO nu 
       ENDDO mu 
       sip_barrier 
       execute eigen_calc_sqr_inv oed_ovl x1 num_lindep
       print "number of dropped linear dependencies"
       print num_lindep
       print " "
#
       DO mu 
       DO nu 
          txx[mu,nu] = oed_ovl[mu,nu]  
       ENDDO nu 
       ENDDO mu 
#
#      Form the Q-matrix --> U s**{-1/2) 
#      --------------------------------- 
#
       PARDO mu, nu  
#
          Txx[mu,nu] = 0.0 
#
          DO lambda 
             T1xx[mu,nu] = x1[mu,lambda]*oed_ovl[lambda,nu] 
             Txx[mu,nu] += T1xx[mu,nu] 
          ENDDO lambda  
#
          PUT Qxx[mu,nu] = Txx[mu,nu]  
#
       ENDPARDO mu, nu  
#
      #execute print_scalar scf_energy
       ENDPROC OVER_HALF 
#      ----------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC FOCK_TRANSPOSE 
#      ------------------- 
#
#      Form the transposed Fock matrix --> Q+ F Q 
#      ------------------------------------------ 
#
       PARDO mu, sigma   
#
             TAxx[mu,sigma] = 0.0 
             TBxx[mu,sigma] = 0.0 
#
             DO lambda 
#
                GET Fpq_a[lambda,sigma] 
                GET Fpq_b[lambda,sigma] 
                GET Qxx[lambda,mu] 
#
                T1xx[mu,sigma]  = Qxx[lambda,mu]*Fpq_a[lambda,sigma]  
                TAxx[mu,sigma] += T1xx[mu,sigma] 
#
                T1xx[mu,sigma]  = Qxx[lambda,mu]*Fpq_b[lambda,sigma]  
                TBxx[mu,sigma] += T1xx[mu,sigma] 
#
             ENDDO lambda 
#
             DO nu 
#
                GET Qxx[sigma,nu] 
#
                T1xx[mu,nu] =        TAxx[mu,sigma]*Qxx[sigma,nu] 
                PUT FTpq_a[mu,nu] += T1xx[mu,nu] 
#
                T2xx[mu,nu]        = TBxx[mu,sigma]*Qxx[sigma,nu] 
                PUT FTpq_b[mu,nu] += T2xx[mu,nu] 
#
             ENDDO nu 
#
       ENDPARDO mu, sigma   
#
       ENDPROC FOCK_TRANSPOSE 
#      ---------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC FOCK_DIAG  
#      -------------- 
#
#      First put the transposed Fock arrays into static arrays 
#      ------------------------------------------------------- 
#
       DO mu   
       DO nu  
#
          GET             FTpq_a[mu,nu] 
          GET             FTpq_b[mu,nu]
#
          FSpq_a[mu,nu] = FTpq_a[mu,nu]
          FSpq_b[mu,nu] = FTpq_b[mu,nu]
#
       ENDDO nu  
       ENDDO mu   
#
       execute eigen_calc FSpq_a ca
#
       ENDPROC FOCK_DIAG 
#      ----------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC C_BTRAN 
#      ------------ 
#
#      Transform the coefficient array back to the original basis 
#      ---------------------------------------------------------- 
#
       PARDO mu, p  
#
          Txp[mu,p] = 0.0 
#
          DO nu 
#
             GET          Qxx[mu,nu] 
#
             T1xp[mu,p] = Qxx[mu,nu]*ca[nu,p]   
             Txp[mu,p] += T1xp[mu,p] 
#
          ENDDO nu 
#
          PUT CBT_a[mu,p] = Txp[mu,p] 
#
       ENDPARDO mu, p  
#
       PARDO mu, q
# 
          Txq[mu,q] = 0.0 
#
          DO nu 
#
             GET          Qxx[mu,nu] 
#
             T1xq[mu,q] = Qxx[mu,nu]*ca[nu,q]   
             Txq[mu,q] += T1xq[mu,q] 
#
          ENDDO nu 
#
          PUT CBT_b[mu,q] = Txq[mu,q] 
#
       ENDPARDO mu, q
       sip_barrier 
#
#      Put the transformed coefficients into static arrays 
#      --------------------------------------------------- 
#
       DO mu 
       DO p 
          GET        CBT_a[mu,p] 
          ca[mu,p] = CBT_a[mu,p] 
       ENDDO p 
       ENDDO mu  
#
       ENDPROC C_BTRAN 
#      --------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC HFDENS_ZERO   
#      ----------------  
#  
#      Zero out the n-1'th density array. 
#      ---------------------------------- 
#
       PARDO mu, nu 
#
             Txx[mu,nu]   = 0.0   
             PUT DHFa_old[mu,nu] = Txx[mu,nu]  
             PUT DHFb_old[mu,nu] = Txx[mu,nu]  
#
       ENDPARDO mu, nu 
#
       ENDPROC HFDENS_ZERO   
#      ------------------- 
#
# ---------------------------------------------------------------------------- 
#
       PROC HFDENS_REPLACE    
#      -------------------   
#
#      Replace the 'old' HF density by the 'new' HF density. 
#      ----------------------------------------------------- 
#
       PARDO mu, nu 
#
             GET DHFa[mu,nu] 
             GET DHFb[mu,nu] 
             PUT DHFa_old[mu,nu] = DHFa[mu,nu]  
             PUT DHFb_old[mu,nu] = DHFb[mu,nu]  
#
       ENDPARDO mu, nu 
#
       ENDPROC HFDENS_REPLACE    
#      ----------------------  
#
# ---------------------------------------------------------------------------- 
#
       PROC GEN_6HISTORY  
#      ------------------  
#
      #DELETE FFai
      #DELETE FFbj
      #CREATE FFai
      #CREATE FFbj
       PARDO a, i 
             tai[a,i] = 0.0 
             PUT FFai[a,i] = tai[a,i] 
       ENDPARDO a, i 
       PARDO b, j 
             tbj[b,j] = 0.0 
             PUT FFbj[b,j] = tbj[b,j] 
       ENDPARDO b, j 
       sip_barrier 
#  
       PARDO mu, nu  
             GET Fpq_a[mu,nu]  
             GET Fpq_b[mu,nu]  
             DO i 
                txi[mu,i] = Fpq_a[mu,nu]*ca[nu,i] 
                DO a 
                   tai[a,i]      = txi[mu,i]*ca[mu,a] 
                   PUT FFai[a,i] += tai[a,i] 
                ENDDO a 
             ENDDO i 
#
             DO j 
                txj[mu,j] = Fpq_b[mu,nu]*ca[nu,j] 
                DO b 
                   tbj[b,j]      = txj[mu,j]*ca[mu,b] 
                   PUT FFbj[b,j] += tbj[b,j] 
                ENDDO b 
             ENDDO j 
       ENDPARDO mu, nu  
       sip_barrier 
#
       n1 = diis_start  
       n1-= 1.0  
       DO d1 
          n1 += 1.0 
          if n1 == worder  
#
                PARDO mu, nu 
                   GET              Fpq_a[mu,nu] 
                   GET              Fpq_b[mu,nu] 
                   txx[mu,nu]     = Fpq_a[mu,nu] 
                   PUT Fa[mu,nu,d1] = txx[mu,nu]  
                   txx[mu,nu]     = Fpq_b[mu,nu] 
                   PUT Fb[mu,nu,d1] = txx[mu,nu]  
                ENDPARDO mu, nu 
                PARDO a, i 
                   GET FFai[a,i] 
                   PUT Fai[a,i,d1] = FFai[a,i]  
                ENDPARDO a, i 
                PARDO b, j 
                   GET FFbj[b,j] 
                   PUT Fbj[b,j,d1] = FFbj[b,j]  
                ENDPARDO b, j 
                exit 

          endif # d1 = kiter 
#
       ENDDO d1 
#
       sip_barrier 
#
       ENDPROC GEN_6HISTORY  
#      ---------------------  
#
# ---------------------------------------------------------------------------- 
#
       PROC MOVE6    
#      ----------  
#
#      Move histories 
#      -------------- 
#
       PARDO mu, nu 
          n1 = 0.0 
          DO d1 
             n1 += 1.0 
             GET          Fa[mu,nu,d1] 
             tpq[mu,nu] = Fa[mu,nu,d1] 
             n2 = 0.0 
          DO d2 
             n2 += 1.0 
             etemp = n1 
             etemp-= n2 
             if etemp == 1.0 
               #tpqx(mu,nu,d2)   = tpq(mu,nu) 
               #PUT Fa(mu,nu,d2) = tpqx(mu,nu,d2) 
                PUT Fa[mu,nu,d2] = tpq[mu,nu] 
             endif 
          ENDDO d2 
          ENDDO d1 
       ENDPARDO mu, nu 
#
       PARDO a, i 
          n1 = 0.0 
          DO d1 
             n1 += 1.0 
             GET        Fai[a,i,d1] 
             tai[a,i] = Fai[a,i,d1] 
             n2 = 0.0 
          DO d2 
             n2 += 1.0 
             etemp = n1 
             etemp-= n2 
             if etemp == 1.0 
               #taix(a,i,d2)   = tai(a,i) 
               #PUT Fai(a,i,d2) = taix(a,i,d2) 
                PUT Fai[a,i,d2] = tai[a,i] 
             endif 
          ENDDO d2 
          ENDDO d1 
       ENDPARDO a,i  
#
       PARDO mu, nu 
          n1 = 0.0 
          DO d1 
             n1 += 1.0 
             GET          Fb[mu,nu,d1] 
             tpq[mu,nu] = Fb[mu,nu,d1] 
             n2 = 0.0 
          DO d2 
             n2 += 1.0 
             etemp = n1 
             etemp-= n2 
             if etemp == 1.0 
               #tpqx(mu,nu,d2)   = tpq(mu,nu) 
               #PUT Fb(mu,nu,d2) = tpqx(mu,nu,d2) 
                PUT Fb[mu,nu,d2] = tpq[mu,nu] 
             endif 
          ENDDO d2 
          ENDDO d1 
       ENDPARDO mu, nu 
#
       PARDO b, j 
          n1 = 0.0 
          DO d1 
             n1 += 1.0 
             GET        Fbj[b,j,d1] 
             tbj[b,j] = Fbj[b,j,d1] 
             n2 = 0.0 
          DO d2 
             n2 += 1.0 
             etemp = n1 
             etemp-= n2 
             if etemp == 1.0 
               #tbjx(b,j,d2)   = tbj(b,j) 
               #PUT Fbj(b,j,d2) = tbjx(b,j,d2) 
                PUT Fbj[b,j,d2] = tbj[b,j] 
             endif 
          ENDDO d2 
          ENDDO d1 
       ENDPARDO b,j  
                
       sip_barrier 
#
       ENDPROC MOVE6    
#      -------------  
#
# ---------------------------------------------------------------------------- 
#
       PROC DIISN   
#      ----------  
#
# The DIIS expansion coefficients are computed using the <= worder  previous iterations.
#
#      Zero out scalars.
#      -----------------
#
      #CALL ZERO_SCALAR 
#
       sip_barrier 
#
#      Determine the 'B-matrix'. 
#      ------------------------- 
#
#      Contributions from Fai histories. 
#      --------------------------------- 

       temp_order = worder
      #if diis_order < worder 
      #   temp_order = diis_order 
      #endif 
          
#
       n1 = 0.0 
       DO d1 
          n1+= 1.0 
       if n1 <= temp_order # worder 
          n2 = 0.0 
       DO d2 
          n2+= 1.0 
       if n2 <= temp_order # worder 
          tdd[d1,d2] = 0.0 
          DO a  
          DO i 
             GET           Fai[a,i,d1] 
             GET           Fai[a,i,d2] 
             tai[a,i]    = Fai[a,i,d1] 
             t1ai[a,i]   = Fai[a,i,d2] 
             etemp       = tai[a,i]*t1ai[a,i] 
             t1dd[d1,d2] = etemp 
             tdd[d1,d2] += t1dd[d1,d2]  
          ENDDO i 
          ENDDO a  
          DO b  
          DO j 
             GET           Fbj[b,j,d1] 
             GET           Fbj[b,j,d2] 
             tbj[b,j]    = Fbj[b,j,d1] 
             t1bj[b,j]   = Fbj[b,j,d2] 
             etemp       = tbj[b,j]*t1bj[b,j] 
             t1dd[d1,d2] = etemp 
             tdd[d1,d2] += t1dd[d1,d2]  
          ENDDO j 
          ENDDO b  
          BB[d1,d2] = tdd[d1,d2] 

       endif 
       ENDDO d2 
       endif 
       ENDDO d1 
#
       execute compute_diis BB 
#
#      Now the unique elements of the 'B-matrix' have been computed and the array filled out.
#      --------------------------------------------------------------------------------------
#
       sip_barrier
#
#      Done computing the c-vector.
#      ----------------------------
#
#      Form the update Density matrix using the c-vector. 
#      -----------------------------------------------
#
       PARDO mu, nu 
#
           txx[mu,nu] = 0.0 
#
           n1 = 0.0 
           DO d1   
              n1 += 1.0 
           if n1 <= temp_order # worder 
              GET            Fa[mu,nu,d1] 
              t1xx[mu,nu]  = Fa[mu,nu,d1] 
              execute return_sval BB[d1,d1] etemp 
             #etemp        = BB(d1,d1)        
              t1xx[mu,nu] *= etemp   
              txx[mu,nu]  += t1xx[mu,nu] 
           endif 
           ENDDO d1   
#
           PUT Fpq_a[mu,nu] = txx[mu,nu] 
#
           txx[mu,nu] = 0.0 
#
           n1 = 0.0 
           DO d1   
              n1 += 1.0 
           if n1 <= temp_order # worder 
              GET            Fb[mu,nu,d1] 
              t1xx[mu,nu]  = Fb[mu,nu,d1] 
              execute return_sval BB[d1,d1] etemp 
             #etemp        = BB(d1,d1)        
              t1xx[mu,nu] *= etemp   
              txx[mu,nu]  += t1xx[mu,nu] 
           endif 
           ENDDO d1   
#
           PUT Fpq_b[mu,nu] = txx[mu,nu] 
#
       ENDPARDO mu, nu 
#
       sip_barrier 
#
       ENDPROC DIISN   
#      -------------  
#
# ---------------------------------------------------------------------------- 
#
      PROC IGUESS
         execute get_my_rank rank 
       if rank == 0.0 
         DO mu  
         DO nu 
            Txx[mu,nu]      = 0.0
            execute return_h1 Txx[mu,nu]
            PUT Fpq_a[mu,nu] = Txx[mu,nu]
            PUT Fpq_b[mu,nu] = Txx[mu,nu]
         ENDDO nu 
         ENDDO mu  
       endif 
      ENDPROC IGUESS

    PROC form_Dscf

    pardo mu,nu
        Txx[mu,nu] = 0.0
        prepare Dxx_scf[mu,nu] = Txx[mu,nu]
    endpardo mu,nu
    server_barrier
    pardo mu,nu
        Txx[mu,nu] = 0.0
        do i
            T1xx[mu,nu] = Ca[mu,i]*Ca[nu,i]
            Txx[mu,nu] += T1xx[mu,nu]
        enddo i
        Txx[mu,nu] *= -2.0
        prepare Dxx_scf[mu,nu] += Txx[mu,nu]
    endpardo mu,nu
    server_barrier

    do ixyz
        ncount2 = (scalar)ixyz
        dsum = 0.0
        esum = 0.0
        pardo mu,nu
            request Dxx_scf[mu,nu]
            ncount1 = 0.0
            execute compute_dipole_integrals DAOINT[mu,nu] ncount1 ncount2
            NucDip[ixyz] = ncount1
            Txx[mu,nu] = Dxx_scf[mu,nu]
            etemp = Txx[mu,nu]*DAOINT[mu,nu]
            esum += etemp
        endpardo mu,nu
        server_barrier
        collective dsum += esum
        server_barrier
        dsum += NucDip[ixyz]
        dipole[ixyz] = dsum
    enddo ixyz

    server_barrier

    ENDPROC form_Dscf

#  
# ---------------------------------------------------------------------------- 
#
############################################################################## 
#
#                         START OF MAIN PROGRAM 
#
############################################################################## 
#
#     Define a few constants 
#     ---------------------- 
#
      ecrit  = scf_conv # Energy tolerance  
     #damp   = 0.0 
      etemp  = 1.0 
      etemp += damp  
      damp1  = 1.0/etemp         # 1/(1+damp)  
      pcount = 0.0 
      print damp 
      print damp1
#
#     Compute the nuclear-nuclear repulsion energy  
#     -------------------------------------------- 
      execute compute_nn_repulsion repulsion
      print repulsion 
#
#     New HF density 
#     -------------- 
#
      CREATE DHFa   
      CREATE DHFb   
      sip_barrier 
      PARDO mu, nu 
            txx[mu,nu]      = 0.0  
            PUT Dhfa[mu,nu] = txx[mu,nu]
            txx[mu,nu]      = 0.0  
            PUT Dhfb[mu,nu] = txx[mu,nu]
      ENDPARDO mu, nu 

#     Get memory requirements from integral calculation 
#     ------------------------------------------------- 
      imax = 0.0 
      zmax = 0.0 
     #DO mu 
     #DO nu 
     #   txx(mu,nu) = 0.0
     #   execute compute_int_scratchmem txx(mu,nu) zmax imax
         execute compute_int_scratchmem oed_ovl zmax imax 
     #ENDDO nu 
     #ENDDO mu 
     server_barrier 

#
#     Perform initial (aa|bb) integral computation to set Schwartz paramaters 
#     ----------------------------------------------------------------------- 
#
#### JNB fix later.
#      DO mu
#      DO nu
#      DO lambda
#      DO sigma
#            IF mu == lambda
#            IF nu == sigma
#               aoint[mu,nu,lambda,sigma] = 0.0 
#               execute compute_aabb_batch aoint[mu,nu,lambda,sigma] screen_array 
#            ENDIF
#            ENDIF
#      ENDDO sigma
#      ENDDO lambda
#      ENDDO nu
#      ENDDO mu

#     do g51 
#     do g52 
#     enddo g52 
#     enddo g51 

      zero = 0.0 
      mone = -1.0 
      one = 1.0 
      two = 2.0 
      three = 3.0 
      four = 4.0 
      diis_count = 0.0  
      diis_start = 2.0 
      diis_end = 5000.0 
      diis_order = 8.0 
      diis_max_order = 10.0 

      diis_start = 0.0
      do kbeg
         diis_start += 1.0
      ENDDO kbeg

      diis_order = 0.0
      do korder
         diis_order += 1.0
      ENDDO korder

      #print_scalar diis_start
      #print_scalar diis_order
#
# Zero out the DIIS vectors 
# 

      PARDO a, i  
            tai[a,i] = 0.0 
            do d1 
               PUT Fai[a,i,d1] = tai[a,i] 
            enddo d1 
      ENDPARDO a, i  

      PARDO b, j  
            tbj[b,j] = 0.0 
            do d1 
               PUT Fbj[b,j,d1] = tbj[b,j] 
            enddo d1 
      ENDPARDO b, j  

      PARDO mu, nu 
            txx[mu,nu] = 0.0 
            do d1 
               PUT Fa[mu,nu,d1] = txx[mu,nu]  
               PUT Fb[mu,nu,d1] = txx[mu,nu]  
            enddo d1 
      ENDPARDO mu, nu 

#
#     Create the one-particle arrays needed for the computation. 
#     ---------------------------------------------------------- 
#
#     Fock matrix
#     ----------- 
      CREATE Fpq_a  
      CREATE Fpq_b  
#
#     Old HF density 
#     -------------- 
#
      CREATE DHFa_old    
      CREATE DHFb_old    
#
#     DIIS vectors 
#     ------------ 
#
      create Fa 
      create Fb 
      create Fai  
      create Fbj  
      CREATE FFai
      CREATE FFbj
#
#     Orthonormalizing transformation coefficient
#     ------------------------------------------- 
#
      CREATE Qxx 
      sip_barrier 
#
#     Construct the initial guess of the Fock matrix.
#     -----------------------------------------------
#    
      esum = 0.0
      esum1= 0.0
      sip_barrier

     #if dens_check == -1.0 
      CALL IGUESS 
     #endif 
     # print_scalar dens_check 

#     Construct the array S**(-1/2) 
#     ----------------------------- 
#
      CALL OVER_HALF 
      sip_barrier 

      DO mu
      DO nu
         GET              DHFa[mu,nu]
         GET              DHFb[mu,nu]
         oed_ovl[mu,nu] = DHFa[mu,nu] # 13
         oed_kin[mu,nu] = DHFb[mu,nu] # 12
      ENDDO nu
      ENDDO mu

      CALL FOCK_MATRIX_FAST 
#
#     Construct S^(-1/2) F S^(-1/2) 
#     ----------------------------- 
#
      CREATE FTpq_a  
      CREATE FTpq_b  
      sip_barrier 
      CALL FOCK_TRANSPOSE 
      sip_barrier 
#
#     -------------------------------------- 
#
      CALL FOCK_DIAG 
#
#     Back transform the coefficient array 
#     ------------------------------------ 
#
      CREATE CBT_a 
      CREATE CBT_b 
      sip_barrier
      CALL   C_BTRAN 
      sip_barrier
#
#     Zero out the 'old' HF density 
#     ----------------------------- 
#
      CALL HFDENS_ZERO 
      sip_barrier
#
#     Compute the HF density 
#     ---------------------- 
#
      CALL HFIDENS

      DO mu 
      DO nu 
         txx[mu,nu] = 0.0 
         Fockrohf_a[mu,nu] = txx[mu,nu]  
         Fockrohf_b[mu,nu] = txx[mu,nu]  
         txx[mu,nu] = oed_ovl[mu,nu]  
      ENDDO nu 
      ENDDO mu 

      dens_check = -1.0 
#      execute scf_atom dens_check   # VFL Commented out

      if dens_check == 1.0 

         DO mu 
         DO nu 
            txx[mu,nu]      = Fockrohf_a[mu,nu]  
            PUT Dhfa[mu,nu] = txx[mu,nu]
            txx[mu,nu]      = Fockrohf_b[mu,nu]  
            PUT Dhfb[mu,nu] = txx[mu,nu]
         ENDDO nu 
         ENDDO mu 

      endif 
      
      sip_barrier
#
#     Damp the HF density 
#     ------------------- 
#
#     CALL HF_DAMP 
#     execute sip_barrier
#
#     Compute the energy 
#     ------------------ 
#
      CALL HF_ENERGY 
      energy1 = energy 
      sip_barrier
#
#     Replace 'old' HF density by 'new' HF density 
#     -------------------------------------------- 
#
      CALL HFDENS_REPLACE 
#
#     Create history arrays 
#     --------------------- 
#
      sip_barrier
#
      DELETE FTpq_a  
      DELETE FTpq_b  
      DELETE Fpq_a  
      DELETE Fpq_b  
      DELETE CBT_a 
      DELETE CBT_b 
#
# Start iterations 
# ---------------- 
#
      DO kiter 
         print " "
	 print kiter
         diis_count += 1.0 
#
#        Create 1-particle arrays 
#        ------------------------ 
#
         CREATE Fpq_a 
         CREATE Fpq_b 
         CREATE CBT_a 
         CREATE CBT_b 
         CREATE FTpq_a  
         CREATE FTpq_b  
         sip_barrier
#
#        Construct the new Fock matrix 
#        -----------------------------

         DO mu
         DO nu
            GET              DHFa[mu,nu]
            GET              DHFb[mu,nu]
            oed_ovl[mu,nu] = DHFa[mu,nu] # 13
            oed_kin[mu,nu] = DHFb[mu,nu] # 12
         ENDDO nu
         ENDDO mu

         CALL FOCK_MATRIX_FAST 
        #CALL FOCK_MATRIX 
         sip_barrier 
#
         CALL HF_ENERGY 
         energy2 = energy 
         sip_barrier
#
#        DONE Compute the DIIS  
#        --------------------- 

         if diis_count < diis_end 

         etemp = diis_start 
         etemp-= 1.0  
         etemp+= diis_order   

        #print_scalar diis_start   
        #print_scalar diis_order    
        #print_scalar etemp  

         worder = 0.0  
         n2 = diis_start 
         n2-= 1.0  
         if diis_count >= n2 
         if diis_count <= etemp 
            worder = diis_count  
            worder+= 1.0    
         endif  
         endif  
        #print_scalar worder   

         if diis_count > etemp 
            worder = etemp  
         endif  
         #print_scalar worder  
#
         if worder > 0.0  
            CALL GEN_6HISTORY 
         endif 
         sip_barrier 
#

         if diis_count >= diis_start
             damp   = 0.0
             etemp  = 1.0
             etemp += damp
             damp1  = 1.0/etemp         # 1/(1+damp)  
         if diis_count <= diis_end
            worder -= diis_start
            worder += 1.0
            #print_scalar worder
            damp  = 0.0
            damp1 = 1.0
            CALL DIISN
            etemp = diis_start
            etemp-= 1.0
            etemp+= diis_order
           #print_scalar etemp 
            if diis_count >= etemp
               CALL MOVE6
            endif
         endif
         endif

         endif # diis_end 

#
#        Transpose the new Fock matrix 
#        -----------------------------
#
         CALL FOCK_TRANSPOSE 
         sip_barrier
#
#        Diagonalize the transposed Fock matrix 
#        -------------------------------------- 
#
         CALL FOCK_DIAG 
         sip_barrier
#
#        Back transform the coefficient array 
#        ------------------------------------ 
#
         CALL C_BTRAN 
#
         done = 0.0 
         sip_barrier
#
#        Check on convergence --> largest HF density difference. 
#        ------------------------------------------------------- 
#
         DO mu 
         DO nu 
#
#           Alpha component 
#           --------------- 
#
            GET           DHFa_old[mu,nu] 
            GET           DHFa[mu,nu] 
#
            T1xx[mu,nu]  = DHFa[mu,nu] 
            T1xx[mu,nu] -= DHFa_old[mu,nu] 
            execute check_dconf T1xx[mu,nu] donea  
            if donea > done 
               done = donea 
            endif 
#
#           Beta component 
#           -------------- 
#
            GET           DHFb_old[mu,nu] 
            GET           DHFb[mu,nu] 
#
            Txx[mu,nu]  = DHFb[mu,nu] 
            Txx[mu,nu] -= DHFb_old[mu,nu] 
            execute check_dconf Txx[mu,nu] doneb  
            if doneb > done 
               done = doneb 
            endif 
#
         ENDDO nu 
         ENDDO mu 
         print done 
	 assert_same done
#
#        Check on convergence using density difference. 
#        ---------------------------------------------- 
#
         IF 1 < kiter # > 1
           #print_scalar diis_count 
            IF done < ecrit
           #print_scalar diis_count 
               DELETE FTpq_a
               DELETE FTpq_b
               DELETE CBT_a
               DELETE CBT_b
               exit
            ENDIF
         ENDIF
#
#        Replace 'old' HF density by 'new' HF density 
#        -------------------------------------------- 
#
         sip_barrier
         CALL HFDENS_REPLACE 
         sip_barrier
#
#        Reset eold --> enew
#        -------------------
#
         energy1 = energy2  
#
#        Compute the HF density 
#        ---------------------- 
#
         CALL HFDENS
         sip_barrier
#
#        Delete one-particle arrays to be used in the next iteration. 
#        ------------------------------------------------------------ 
#
         if kiter < scf_iter
            DELETE Fpq_a 
            DELETE Fpq_b 
         endif

         DELETE FTpq_a  
         DELETE FTpq_b  
         DELETE CBT_a 
         DELETE CBT_b 
#
      ENDDO kiter 
#
#     Release unneeded memory blocks.
#
      sip_barrier
      DELETE DHFA
      DELETE DHFB
      DELETE DHFA_OLD
      DELETE DHFB_OLD

      CREATE FTa 
      CREATE FTb 
      sip_barrier 
      PARDO mu, nu 
            GET Fpq_a[mu,nu] 
            DO p 
               Txp[mu,p] = Fpq_a[mu,nu]*ca[nu,p] 
               DO p1 
                  Tpp[p1,p] = Txp[mu,p]*ca[mu,p1] 
                  PUT FTa[p1,p] += Tpp[p1,p] 
               ENDDO p1  
            ENDDO p 
      ENDPARDO mu, nu  
#     
      PARDO mu, nu 
            GET Fpq_b[mu,nu] 
            DO q 
               Txq[mu,q] = Fpq_b[mu,nu]*ca[nu,q] 
               DO q1 
                  Tqq[q1,q] = Txq[mu,q]*ca[mu,q1] 
                  PUT FTb[q1,q] += Tqq[q1,q] 
               ENDDO q1  
            ENDDO q 
      ENDPARDO mu, nu  
      sip_barrier 
#
#     Put the final Fock arrays into predefined arrays 
#     ------------------------------------------------ 
#
      DO p
      DO p1
         GET FTa[p,p1]
         Fock_a[p,p1] = FTa[p,p1]
      ENDDO p1
      ENDDO p

      create Dca 
      sip_barrier

     #VFL execute print_rel_info two pinf
     #VFL execute print_rel_info three Fock_a
     #execute get_my_rank rank
     #if rank == 0.0
         PARDO mu, p
            txp[mu,p] = ca[mu,p]
            PUT Dca[mu,p] = txp[mu,p] 
         ENDPARDO mu, p
      #VFL execute print_rel_info zero ca
     #endif
      sip_barrier

      set_persistent ca "ca" 
      set_persistent Fock_a "fock_a" 
#     set_persistent energy "energy" 

      scf_energy  = energy2
      totenerg = scf_energy
      print scf_energy

	call form_Dscf
	print " "
	print "SCF dipole moments"
	print dipole

      set_persistent scf_energy "scf_energy"
      set_persistent dipole "scf_dipole"
      set_persistent NucDip "nuclear_dipole"
      sip_barrier
#                         
#
                           ENDSIAL SCF_RHF_COREH          
#
###############################################################################
#
